<!DOCTYPE html>

<html lang="fr">
<head>
<!-- deploy: 2025-12-29-02 -->
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<title>Suivi Calories &amp; Nutrition (local)</title>
<style>
/* ======================================================
   0) TOKENS / VARIABLES
   ====================================================== */
:root{
  --bg:#0b1020;
  --panel:rgba(255,255,255,.08);
  --panel2:rgba(255,255,255,.06);
  --border:rgba(255,255,255,.14);
  --text:rgba(255,255,255,.92);
  --muted:rgba(255,255,255,.70);
  --muted2:rgba(255,255,255,.55);
  --shadow: 0 18px 55px rgba(0,0,0,.35);
  --radius: 18px;

  --ok: rgba(46, 204, 113, .16);
  --warn: rgba(241, 196, 15, .16);
  --bad: rgba(231, 76, 60, .16);

  --ok-b: rgba(46, 204, 113, .35);
  --warn-b: rgba(241, 196, 15, .35);
  --bad-b: rgba(231, 76, 60, .35);

  --accent: #7c5cff;
  --accent2:#2dd4bf;
}

/* ======================================================
   1) RESET / BASE
   ====================================================== */
*{box-sizing:border-box}
html, body{
  max-width:100%;
  overflow-x:hidden;
}

body{
  font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
  margin:0;
  color:var(--text);
  background:
    radial-gradient(1100px 700px at 12% 12%, rgba(124,92,255,.25), transparent 60%),
    radial-gradient(1000px 700px at 90% 10%, rgba(45,212,191,.20), transparent 55%),
    radial-gradient(900px 700px at 50% 110%, rgba(255,255,255,.08), transparent 55%),
    var(--bg);
  line-height:1.35;
}

.container{
  max-width: 1050px;
  margin: 0 auto;
  padding: 16px;
  padding-top: 78px; /* ← compense la hauteur de la appbar fixe */
}

h1{
  font-size:1.25rem;
  margin:.2rem 0 .6rem;
  letter-spacing:.2px;
}
h2{margin:.1rem 0 .6rem;font-size:1.05rem}
h3{margin:.1rem 0 .6rem;font-size:1rem}

.muted{color:var(--muted);font-size:.92rem}
.muted small{color:var(--muted2)}
a{color:inherit}

/* ======================================================
   2) APPBAR / BRAND / NAV
   ====================================================== */
.appbar{
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  z-index: 1000;

  backdrop-filter: blur(12px);
  background: linear-gradient(to bottom, rgba(11,16,32,.88), rgba(11,16,32,.68));
  border-bottom:1px solid rgba(255,255,255,.10);
}
.appbar__inner{
  display:flex; align-items:center; gap:12px;
  max-width:1050px;
  margin:0 auto;
  padding: 12px 16px;
}
.brand{
  display:flex; align-items:center; gap:10px;
  min-width: 240px;
}

.logoDot{
  width:34px;
  height:34px;
  border-radius:12px;

  background: linear-gradient(135deg, var(--accent), var(--accent2));
  box-shadow: 0 10px 30px rgba(124,92,255,.25);

  border:0;
  cursor:pointer;

  display:inline-flex;
  align-items:center;
  justify-content:center;

  color:rgba(255,255,255,.95);
  font-weight:900;
  font-size:18px;
  line-height:1;
  padding:0;
}
.logoDot:hover{ filter:brightness(1.05); }
.logoDot:active{ transform: translateY(1px); }
.logoDot:focus{
  outline:none;
  box-shadow:
    0 0 0 4px rgba(124,92,255,.25),
    0 10px 30px rgba(124,92,255,.25);
}

.brandTitle{font-weight:800; line-height:1.05}
.brandSub{font-size:.82rem;color:var(--muted); margin-top:2px}

/* Brand + menu intégré */
.brand--with-menu{
  display:flex;
  align-items:center;
  gap:10px;
  position:relative;
}
.brandText{ min-width:0; }

.menuBtn--brand{
  width:34px;
  height:34px;
  padding:0;
  border-radius:12px;
  display:inline-flex;
  align-items:center;
  justify-content:center;
  font-size:18px;
}

/* Nav / menu panel */
.nav{
  position:relative;
  display:flex;
  align-items:center;
  gap:10px;
}

.menuBtn{
  width:auto;
  min-width:auto;
  padding:.5rem .75rem;
  border-radius: 14px;
  border:1px solid rgba(255,255,255,.18);
  background: rgba(255,255,255,.06);
  color:var(--text);
  cursor:pointer;
  font-weight:800;
  line-height:1;
}
.menuBtn:hover{ background: rgba(255,255,255,.10); }
.menuBtn:active{ transform: translateY(1px); }

.menuPanel{
  position:absolute;
  left:0;
  top: calc(100% + 10px);
  width: min(240px, 84vw);
  padding: 10px;
  border-radius: 16px;
  border:1px solid rgba(255,255,255,.14);
  background: rgba(12,16,28,.96);
  box-shadow: 0 20px 70px rgba(0,0,0,.55);
  display:none;
  z-index: 1100;
}
.menuPanel.is-open{ display:block; }

.menuItem{
  width:100%;
  text-align:left;
  padding:.55rem .65rem;
  border-radius: 12px;
  border:1px solid rgba(255,255,255,.12);
  background: rgba(255,255,255,.06);
  color:var(--text);
  cursor:pointer;
  font-weight:700;
  margin:6px 0;
}
.menuItem:hover{ background: rgba(255,255,255,.10); }

.menuItem.is-active{
  background: linear-gradient(135deg, rgba(124,92,255,.35), rgba(45,212,191,.25));
  border-color: rgba(255,255,255,.28);
}

/* Masque l’ancien bloc tabs */
.tabs{ display:none !important; }

/* ======================================================
   3) LAYOUT / CARDS / FORMS
   ====================================================== */
.grid{display:grid;grid-template-columns:1fr;gap:.9rem}
@media(min-width:980px){.grid{grid-template-columns:1fr 1fr}}

.card{
  border:1px solid rgba(255,255,255,.12);
  border-radius: var(--radius);
  background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.05));
  box-shadow: var(--shadow);
  padding: 1rem;
  margin: .9rem 0;
  width:100%;
}

label{
  display:block;
  font-size:.92rem;
  margin:.2rem 0 .25rem;
  color: rgba(255,255,255,.82);
  font-weight:650;
}

input,select,button,textarea{
  width:100%;
  padding:.55rem .6rem;
  border-radius: 14px;
  border: 1px solid rgba(255,255,255,.16);
  background: rgba(0,0,0,.16);
  color: var(--text);
  font-size:.98rem;
  outline:none;
}

input::placeholder, textarea::placeholder{color: rgba(255,255,255,.45)}
input:focus,select:focus,textarea:focus{
  border-color: rgba(124,92,255,.55);
  box-shadow: 0 0 0 4px rgba(124,92,255,.20);
}

button{
  border:1px solid rgba(255,255,255,.18);
  background: linear-gradient(135deg, rgba(124,92,255,.35), rgba(124,92,255,.15));
  cursor:pointer;
  font-weight:750;
}
button:hover{filter: brightness(1.05)}
.btn-danger{
  border-color: rgba(231,76,60,.55);
  background: linear-gradient(135deg, rgba(231,76,60,.35), rgba(231,76,60,.15));
}
.btn-mini{
  padding:.28rem .55rem;
  border-radius: 12px;
  width:auto;
}

.row{display:flex;gap:.7rem;flex-wrap:wrap}
.row > div{flex:1;min-width:190px}

.kpi{display:flex;gap:.6rem;flex-wrap:wrap;margin:.7rem 0}
.kpi div{
  background: rgba(255,255,255,.06);
  border:1px solid rgba(255,255,255,.12);
  border-radius: 16px;
  padding:.55rem .7rem;
}
.kpi b{display:block;color: rgba(255,255,255,.90); margin-bottom:2px}

.ok{background: var(--ok) !important; border-color: var(--ok-b) !important}
.warn{background: var(--warn) !important; border-color: var(--warn-b) !important}
.bad{background: var(--bad) !important; border-color: var(--bad-b) !important}

/* autorise shrink dans grid */
.grid > * { min-width: 0; }
.card { min-width: 0; }

/* ======================================================
   4) TABLES / WRAPPERS
   ====================================================== */
.meals-wrap{ overflow-x:auto; -webkit-overflow-scrolling:touch; width:100%; max-width:100%; }
.meals-wrap table.wide-table{
  width: max-content;
  min-width: 600px;
  table-layout: fixed;
}

/* colonnes wide-table */
.meals-wrap table.wide-table th:nth-child(1),
.meals-wrap table.wide-table td:nth-child(1){ width: 70px; }

.meals-wrap table.wide-table th:nth-child(2),
.meals-wrap table.wide-table td:nth-child(2){ width: 50px; }

.meals-wrap table.wide-table th:nth-child(3),
.meals-wrap table.wide-table td:nth-child(3),
.meals-wrap table.wide-table th:nth-child(4),
.meals-wrap table.wide-table td:nth-child(4),
.meals-wrap table.wide-table th:nth-child(5),
.meals-wrap table.wide-table td:nth-child(5){ width: 50px; }

.meals-wrap table.wide-table th:nth-child(6),
.meals-wrap table.wide-table td:nth-child(6){ width: 20px; }

.meals-wrap th, .meals-wrap td{ white-space: nowrap; }
.meals-wrap td{ min-width:0; }
.meals-wrap td input{ width:100%; min-width:0; box-sizing:border-box; }

/* Historique */
.history-table{ table-layout: fixed; }

/* colonnes history-table */
.history-table th:nth-child(1),
.history-table td:nth-child(1){ width: 110px; }

.history-table th:nth-child(2),
.history-table td:nth-child(2){ width: 80px; }

.history-table th:nth-child(3),
.history-table td:nth-child(3){ width: 90px; }

.history-table th:nth-child(4),
.history-table td:nth-child(4){ width: 120px; }

.history-table th:nth-child(5),
.history-table td:nth-child(5){ width: 160px; }

.history-table th:nth-child(6),
.history-table td:nth-child(6){ width: 90px; }

.history-table th:nth-child(7),
.history-table td:nth-child(7){ width: 100px; }

.history-table th:nth-child(8),
.history-table td:nth-child(8){ width: 70px; }

.history-table th:nth-child(9),
.history-table td:nth-child(9){ width: 90px; }

/* table-wrap (défini 2 fois dans ton CSS : on le garde tel quel) */
.table-wrap{
  overflow-x:auto;
  -webkit-overflow-scrolling:touch;
  width:100%;
  border-radius: 16px;
}
.table-wrap{
  overflow-x:auto;
  -webkit-overflow-scrolling:touch;
  width:100%;
  border-radius: 16px;
}

table{width:100%;border-collapse:collapse;margin-top:.5rem;background: rgba(0,0,0,.12)}
th,td{
  border:1px solid rgba(255,255,255,.10);
  padding:.55rem;
  text-align:center
}
th{
  background: rgba(255,255,255,.08);
  color: rgba(255,255,255,.88);
}
.td-left{text-align:left}

/* Table scroll générique */
.table-scroll{
  overflow-x:auto;
  -webkit-overflow-scrolling:touch;
  width:100%;
  max-width:100%;
}
.table-scroll table{
  min-width:720px;
  table-layout:fixed;
}
.table-scroll th,
.table-scroll td{ white-space:nowrap; }
.table-scroll td{ min-width:0; }
.table-scroll td input{
  width:100%;
  min-width:0;
  box-sizing:border-box;
}

/* ======================================================
   5) TEXTAREAS / JSON BOX
   ====================================================== */
textarea{
  min-height:110px;
  font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;
  font-size:.87rem
}

#daysJsonBox{
  min-height: 140px;
  font-family: ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;
  font-size:.85rem;
}

/* ======================================================
   6) NOTICE / WARN BLOCKS
   ====================================================== */
.notice{
  border-radius: 16px;
  border:1px solid rgba(255,255,255,.12);
  padding:.75rem .85rem;
  background: rgba(255,255,255,.06);
  margin:.6rem 0;
}
.notice--warn{background: var(--warn); border-color: var(--warn-b)}
.notice--ok{background: var(--ok); border-color: var(--ok-b)}
.notice--bad{background: var(--bad); border-color: var(--bad-b)}
.noticeTitle{font-weight:850;margin-bottom:.25rem}
.notice p{margin:.25rem 0;color: rgba(255,255,255,.88)}
.notice ul{margin:.35rem 0 0; padding-left:1.1rem; color: rgba(255,255,255,.85)}
.notice li{margin:.15rem 0}

/* Bonus lisibilité messages 7j */
.notice p{ margin: 0 0 .35rem 0; }
.notice ul{ margin: .2rem 0 0 1.1rem; padding: 0; }
.notice ul li{ margin-bottom: .25rem; }

/* ======================================================
   7) TOOLTIP / INFO DOT / MODAL
   ====================================================== */
.h3{margin:.1rem 0 .6rem;font-size:1rem}
.info-dot{
  display:inline-flex;align-items:center;justify-content:center;
  width:22px;height:22px;border-radius:999px;
  border:1px solid rgba(255,255,255,.22);
  font-size:13px;line-height:1;margin-left:.35rem;
  color:rgba(255,255,255,.92);
  background: rgba(0,0,0,.18);
  cursor:pointer; user-select:none;
}

.kpi-info{
  margin-left:.35rem;
  font-weight:900;
  cursor:pointer;
  display:inline-flex;
  align-items:center;
  justify-content:center;
  width:22px;height:22px;
  border-radius:999px;
  border:1px solid rgba(255,255,255,.22);
  background: rgba(0,0,0,.18);
}

/* Tooltip CSS-only */
.tip{ position:relative; }
.tip::after{
  content: attr(data-tip);
  position:absolute;
  left:50%;
  transform:translateX(-50%);
  bottom: calc(100% + 10px);
  width: min(340px, 90vw);
  white-space: pre-wrap;
  background:#0b0f1a;
  color:#fff;
  border-radius:14px;
  padding:.7rem .8rem;
  font-size:.92rem;
  line-height:1.25;
  opacity:0; visibility:hidden; pointer-events:none;
  z-index:9999;
  box-shadow: 0 14px 40px rgba(0,0,0,.35);
  border:1px solid rgba(255,255,255,.12);
}
.tip::before{
  content:"";
  position:absolute;
  left:50%;
  transform:translateX(-50%);
  bottom: calc(100% + 4px);
  border:6px solid transparent;
  border-top-color:#0b0f1a;
  opacity:0; visibility:hidden; pointer-events:none;
  z-index:9999;
}
.tip:hover::after, .tip:hover::before,
.tip:focus::after, .tip:focus::before,
.tip:focus-visible::after, .tip:focus-visible::before{
  opacity:1; visibility:visible;
}

/* Mini-modale */
.modal{ display:none; }
.modal.is-open{ display:block; }
.modal__backdrop{ position:fixed; inset:0; background:rgba(0,0,0,.55); z-index:9998; }
.modal__panel{
  position:fixed; left:50%; top:50%;
  transform:translate(-50%,-50%);
  width:min(560px, 92vw);
  max-height: 78vh;
  overflow:auto;
  background: rgba(12,16,28,.92);
  border-radius: 18px;
  border:1px solid rgba(255,255,255,.14);
  z-index:9999;
  box-shadow: 0 20px 75px rgba(0,0,0,.55);
}
.modal__head{
  display:flex; align-items:center; justify-content:space-between;
  gap:.6rem;
  padding:.85rem .9rem;
  border-bottom:1px solid rgba(255,255,255,.10);
}
.modal__title{ font-weight:900; }
.modal__close{ width:auto; min-width:auto; padding:.35rem .55rem; border-radius:12px; }
.modal__body{
  padding:.85rem .9rem;
  white-space:pre-wrap;
  line-height:1.35;
  font-size:.98rem;
  color: rgba(255,255,255,.90);
}
.modal__foot{
  padding:.75rem .9rem;
  border-top:1px solid rgba(255,255,255,.10);
  display:flex; justify-content:flex-end;
}

/* ======================================================
   8) SECTIONS / MODES / VISIBILITÉ
   ====================================================== */
.tabSection{ display:none; }
.tabSection.is-active{ display:block; }

[data-um="sport"], [data-um="expert"]{ display:none; }
body[data-usemode="sport"] [data-um="sport"]{ display:block; }
body[data-usemode="expert"] [data-um="sport"],
body[data-usemode="expert"] [data-um="expert"]{ display:block; }

/* Petit badge régime — ATTENTION: contient des // invalides (bug connu) */
.pill{
  display:inline-flex;//align-items:center;gap:.4rem;
  //padding:.2rem .55rem;
 // border:1px solid rgba(255,255,255,.16);
  //border-radius:999px;
  //background: rgba(0,0,0,.18);
 // font-size:.85rem;color: rgba(255,255,255,.90);
}
.pill b{font-weight:800}

details summary::-webkit-details-marker{display:none}
details summary:before{content:"▸ "; display:inline-block; margin-right:.2rem}
details[open] summary:before{content:"▾ "}

/* ======================================================
   9) UTILITIES
   ====================================================== */
.mt-015{ margin-top:.15rem; }
.mt-02{ margin-top:.2rem; }
.mt-025{ margin-top:.25rem; }
.mt-03{ margin-top:.3rem; }
.mt-035{ margin-top:.35rem; }
.mt-04{ margin-top:.4rem; }
.mt-045{ margin-top:.45rem; }
.mt-05{ margin-top:.5rem; }
.mt-055{ margin-top:.55rem; }
.mt-06{ margin-top:.6rem; }

.m-015-0{ margin:.15rem 0 0; }
.m-02-0{ margin:.2rem 0 0; }
.m-03-06{ margin:.3rem 0 .6rem; }

.my06-p08{ margin:.6rem 0; padding:.8rem; }
.mt05-pl11{ margin:.5rem 0 0; padding-left:1.1rem; }
.ml11-mt04-p0{ margin:.4rem 0 0 1.1rem; padding:0; }

.self-end{ align-self:flex-end; }
.cursor-pointer{ cursor:pointer; }
.text-left{ text-align:left; }

.hidden{ display:none; }

.minw220-flex2{ min-width:220px; flex:2; }
.minw240-flex2{ min-width:240px; flex:2; }

.panel-subtle{
  background:rgba(255,255,255,.04);
  border-color:rgba(255,255,255,.10);
  margin:.6rem 0;
  padding:.8rem;
}

/* ======================================================
   10) DIABÈTE — LOCK / EMBED / PANELS
   ====================================================== */
.diab-locked{ opacity:.55; filter:grayscale(1); pointer-events:none; }
.diab-lockmsg{ margin-top:.35rem; }

label.inline{display:flex;gap:.55rem;align-items:center}
label.inline input{width:auto}

.diab-embed{
  width:100%;
  border-radius: 16px;
  overflow:hidden;
  border:1px solid rgba(255,255,255,.12);
  background: rgba(255,255,255,.04);
}
.diab-embed iframe{
  width:100%;
  height: 78vh;
  border:0;
  background:#fff;
}

/* Diab panel intégré */
.span-2{ grid-column: 1 / -1; }

.diab-panel{ position:relative; }
.diab-panel.is-disabled{ opacity:.55; }
.diab-panel.is-disabled *{ pointer-events:none; }
.diab-panel .diab-lock{
  display:none;
  position:absolute;
  inset:0;
  border-radius:16px;
  background: linear-gradient(180deg, rgba(0,0,0,.28), rgba(0,0,0,.12));
  border:1px dashed rgba(255,255,255,.18);
  padding:1rem;
}
.diab-panel.is-disabled .diab-lock{
  display:flex;
  align-items:center;
  justify-content:center;
  text-align:center;
  pointer-events:auto;
}
.diab-lock .muted{opacity:.95}

/* ======================================================
   11) KPI GROUPS — scoped
   ====================================================== */
#kpis .kpis-group{
  display:flex;
  gap:.75rem;
  flex-wrap:wrap;
  margin-bottom:.5rem;
}
#kpis .kpis-group > *{
  flex:1 1 160px;
}
#kpis .kpis-group-diet{
  padding-bottom:.4rem;
  border-bottom:1px solid rgba(255,255,255,.08);
}

/* ======================================================
   12) TOOLTIP PINNÉ (JS)
   ====================================================== */
.kpi-info{
  margin-left:.35rem;
  font-weight:900;
  cursor:pointer;
  display:inline-flex;
  align-items:center;
  justify-content:center;
  width:22px;height:22px;
  border-radius:999px;
  border:1px solid rgba(255,255,255,.22);
  background: rgba(0,0,0,.18);
}

.pinned-tip{
  position:fixed;
  z-index:9999;
  display:none;
  width:min(360px, 92vw);
  max-height:70vh;
  overflow:auto;
  white-space:pre-wrap;
  background:#0b0f1a;
  color:#fff;
  border-radius:14px;
  padding:.7rem .8rem;
  font-size:.92rem;
  line-height:1.25;
  box-shadow: 0 14px 40px rgba(0,0,0,.35);
  border:1px solid rgba(255,255,255,.12);
}

.pinned-tip__head{
  display:flex;
  justify-content:space-between;
  align-items:center;
  gap:.6rem;
  margin-bottom:.4rem;
  font-weight:900;
}

.pinned-tip__close{
  width:auto;
  min-width:auto;
  padding:.2rem .45rem;
  border-radius:10px;
  border:1px solid rgba(255,255,255,.18);
  background: rgba(255,255,255,.06);
  color: var(--text);
  cursor:pointer;
}

/* ======================================================
   13) CGU LOCK
   ====================================================== */
.tabBtn.is-disabled, .menuItem.is-disabled{
  opacity:.45;
  pointer-events:none;
}

/* ======================================================
   14) VIZ — FLOWVIZ
   ====================================================== */
.flowviz{
  display:grid;
  gap:.6rem;
}
.flowviz .flowgrid{
  display:grid;
  grid-template-columns: 1.2fr .8fr;
  gap:.8rem;
}
@media (max-width: 980px){
  .flowviz .flowgrid{ grid-template-columns:1fr; }
}
.flowviz .kv{
  display:grid;
  grid-template-columns: 1fr auto;
  gap:.35rem .8rem;
  align-items:center;
}
.flowviz .kv b{ font-weight:700; }
.flowviz .muted{ opacity:.85; }
.flowviz .barRow{
  display:grid;
  grid-template-columns: 110px 1fr 70px;
  gap:.5rem;
  align-items:center;
}
.flowviz .bar{
  height:12px;
  border-radius:999px;
  background: rgba(255,255,255,.08);
  overflow:hidden;
  border:1px solid rgba(255,255,255,.10);
}
.flowviz .bar > i{
  display:block;
  height:100%;
  width:0%;
  background: rgba(255,255,255,.35);
}
.flowviz .pill{
  display:inline-flex;
  align-items:center;
  gap:.35rem;
  padding:.18rem .55rem;
  border-radius:999px;
  border:1px solid rgba(255,255,255,.16);
  background: rgba(255,255,255,.06);
  font-size:.92rem;
  white-space:nowrap;
}
.flowviz .warn{
  border-color: rgba(255,208,92,.28);
  background: rgba(255,208,92,.10);
}
.flowviz .ok{
  border-color: rgba(123,255,176,.22);
  background: rgba(123,255,176,.10);
}



/* --- Carb repères : panneau explicatif (UI) --- */
.calcPanel{border:1px dashed #d9d9d9;border-radius:12px;padding:.55rem .65rem;background:rgba(0,0,0,.02)}
.calcRow{display:flex;justify-content:space-between;gap:.75rem;align-items:baseline;margin:.15rem 0}
.calcLabel{color:#555;font-size:.88rem}
.calcValue{font-variant-numeric:tabular-nums}
#carbCalcCapSrc{margin-left:.35rem}

</style>
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2">
</script>
<link href="./manifest.webmanifest" rel="manifest"/>
<meta content="#ffffff" name="theme-color"/>
</head>
<body>
<!-- Appbar -->
<div class="appbar">
<div class="appbar__inner">
<!-- BRAND = bouton menu + texte -->
<div class="brand brand--with-menu">
<button aria-controls="menuPanel" aria-expanded="false" aria-haspopup="true" class="logoDot" id="menuBtn" type="button">
          ☰
        </button>
<div class="brandText">
<div class="brandTitle">Montre • Calories &amp; Nutrition</div>
<div class="brandSub">Local • multi-profils • synchro en option</div>
</div>
<!-- Panneau dropdown -->
<div aria-label="Pages" class="menuPanel" id="menuPanel" role="menu">
<button class="menuItem is-active" data-tab="welcome" role="menuitem" type="button">Bienvenue</button>
<button class="menuItem" data-tab="dash" role="menuitem" type="button">Profil</button>
<button class="menuItem hidden" data-tab="diab" id="diabMenuItem" role="menuitem" type="button">Diabète</button>
<button class="menuItem" data-tab="goal" role="menuitem" type="button">Objectif</button>
<button class="menuItem" data-tab="repas" role="menuitem" type="button">Repas</button>
<button class="menuItem" data-tab="journal" role="menuitem" type="button">Historique</button>
<button class="menuItem" data-tab="cloud" role="menuitem" type="button">Données &amp; sauvegarde</button>
<button class="menuItem" data-tab="lexicon" role="menuitem" type="button">Lexique</button>
</div>
</div><!-- /brand -->
</div><!-- /appbar__inner -->
</div><!-- /appbar -->
<div class="container">
<!-- Visible sur toutes les pages -->
<div class="notice notice--warn mt-06">
<div class="noticeTitle">Bon à savoir</div>
<p>
        Tu saisis tes données, l’application calcule des <b>repères</b>.
        <b>La montre reste une estimation</b>.
        Cette application ne remplace pas un avis médical.
      </p>
</div>
<!-- =========================
         WELCOME
         ========================= -->
<section class="tabSection" data-tabsection="welcome">
<div class="card">
<h2>Conditions générales</h2>
<div class="notice notice--warn mt-06">
<div class="noticeTitle">Conditions générales</div>
<label style="display:flex; gap:.6rem; align-items:flex-start; cursor:pointer">
<input id="ackTerms" style="width:auto; margin-top:.15rem" type="checkbox"/>
<span class="muted">
              J’ai lu et compris le rôle de l’application et ses limites d’utilisation.
              (Ce n’est pas un outil médical. Les données affichées sont des repères.)
            </span>
</label>
<div class="muted mt-025">
            Tant que ce n’est pas coché, l’accès aux autres pages est bloqué.
          </div>
</div>
<div class="notice notice--ok">
<div class="noticeTitle">Rôle de l’application</div>
<ul>
<li>
              Outil <b>local</b> de suivi personnel qui centralise ton profil,
              ta dépense du jour (montre) et ton suivi quotidien
              (repas, historique, journal).
            </li>
<li>
              L’application t’aide à <b>te repérer</b> et à observer des tendances,
              pas à décider à ta place.
            </li>
</ul>
</div>
<div class="notice notice--ok">
<div class="noticeTitle">Mode diabète — rôle spécifique</div>
<ul>
<li>
              Le mode diabète propose un <b>journal de suivi personnel</b>
              (glucides, glycémies, notes, contexte).
            </li>
<li>
              Il permet d’observer des <b>tendances</b> et de faire tes propres liens
              entre alimentation, glycémies et ressenti.
            </li>
<li>
              Les informations affichées sont des <b>repères de compréhension</b>,
              pas des prescriptions.
            </li>
</ul>
</div>
<div class="notice notice--warn">
<div class="noticeTitle">Limites d’utilisation</div>
<ul>
<li>
              La dépense issue de la montre est une <b>estimation</b> :
              vise la <b>tendance</b>, pas le chiffre parfait.
            </li>
<li>
              En cas de pathologie, traitement, TCA, grossesse ou doute :
              fais valider tes choix par un <b>professionnel de santé</b>.
            </li>
<li>
              Si fatigue, sommeil ou performances se dégradent :
              ajuste ton déficit, ta charge et ta récupération.
            </li>
<li>
              Les <b>repères glucidiques (g/kg/j)</b> proposés s’appuient sur
              des recommandations générales de nutrition du sport
              (endurance / intensité) et restent des <b>fourchettes indicatives</b>,
              pas des règles fixes.
            </li>
<li>
<b>Limites</b> : l’application ne pose aucun diagnostic
              et n’adapte aucun traitement.
              Les calculs restent des approximations
              (montre, équations, variabilité individuelle, adhérence, etc.).
              Écoute ton corps et ajuste selon ton quotidien
              (faim, performance, poids, glycémies si tu suis).
            </li>
</ul>
</div>
</div><!-- /card -->
</section>
<!-- =========================
     DASHBOARD
     ========================= -->
<section class="tabSection is-active" data-tabsection="dash">
<div class="card" id="positioningCard">
<h2>Mode d'affichage</h2>
<div class="row">
<div>
<label>Choix d'utilisation</label>
<select id="useMode">
<option selected="" value="simple">Simple</option>
<option value="sport">Sportif</option>
<option value="expert">Expert</option>
</select>
<div class="muted mt-025">
          Ce que tu vois, change! Pas les calculs.
        </div>
</div>
<div>
<label>Rappel rapide (selon mode)</label>
<div class="muted mt-015" id="positioningText">
          Simple : Objectif : être régulier sur la semaine.
        </div>
</div>
</div>
</div>
<div class="card">
<h2>Utilisateurs</h2>
<div class="row">
<div>
<label>Utilisateur actuel</label>
<select id="profileSelect"></select>
</div>
<div>
<label>Créer un utilisateur</label>
<input id="profileName" placeholder="ex: Christophe…" type="text"/>
</div>
<div class="self-end">
<button id="btnCreateProfile" type="button">Créer et Choisir</button>
</div>
<div class="self-end">
<button class="btn-danger" id="btnDeleteProfile" type="button">Supprimer cet utilisateur</button>
</div>
</div>
<p class="muted">
      Chaque utilisateur garde ses données séparées sur ce navigateur (repas + jours + poids).
    </p>
</div>
<div class="grid">
<div class="card">
<h2>Mes informations</h2>
<p class="muted">
        Utilisées pour calculer des repères (kcal et macros)
      </p>
<div class="row">
<div>
<label>Sexe</label>
<select id="sex">
<option selected="" value="M">Homme</option>
<option value="F">Femme</option>
</select>
</div>
<div>
<label>Âge</label>
<input id="age" min="0" step="1" type="number" value="0"/>
</div>
</div>
<div class="row">
<div>
<label>Taille</label>
<input id="height" min="0" step="1" type="number" value="0"/>
</div>
<div>
<label>Poids de référence</label>
<input id="weight" min="0" step="0.1" type="number" value="0"/>
</div>
</div>
<p class="muted">
        Le <b>poids de référence</b> sert aux calculs. Ton <b>poids du jour</b> se note dans le Journal pour suivre l’évolution.
      </p>
<div class="row mt-035">
<div>
<label class="inline">
<input id="diabEnabled" type="checkbox"/>
            Activer le journal diabète (glucides + glycémies)
          </label>
<div class="muted mt-015">
<b>Carnet de suivi personnel</b>. L’app ne calcule aucune dose et ne remplace pas un avis médical.
          </div>
</div>
</div>
</div>
<div class="card">
<h2>Ma dépense du jour (montre)</h2>
<div class="row">
<div>
<label>Marque de la montre</label>
<select id="watchBrand">
<option selected="" value="custom">Personnalisé</option>
<option value="apple">Apple</option>
<option value="garmin">Garmin</option>
<option value="polar">Polar</option>
<option value="coros">COROS</option>
<option value="samsung">Samsung</option>
<option value="suunto">Suunto</option>
<option value="huawei">Huawei</option>
<option value="amazfit">Amazfit</option>
<option value="fitbit">Fitbit / Google</option>
</select>
<div class="muted mt-025">
            La montre donne une <b>estimation</b>, pas une valeur exacte.
          </div>
</div>
<!-- Sport+Expert : référence preset (info) -->
<div data-um="sport">
<label>Profil de la montre</label>
<div class="muted mt-015">
            Pourquoi cette prudence ?
            <span aria-label="Pourquoi cette prudence ?" class="info-dot" id="watchProfileInfo" role="button" tabindex="0">ℹ️</span>
</div>
</div>
</div>
<div class="row">
<div>
<label>Calories brûlées (kcal)</label>
<input id="montre" min="0" placeholder="ex: 2600" step="1" type="number" value="2600"/>
<div class="muted">
            Estimation donnée par ta montre pour la journée.
          </div>
</div>
<!-- Sport+Expert : marge d'erreur -->
<div data-um="sport">
<label>Incertitude (en %)</label>
<input id="errPct" min="0" step="1" type="number" value="10"/>
<p class="muted m-015-0">
            Marge utilisée pour corriger l’estimation de la montre. C’est un <b>repère</b>. Pas une valeur exacte.
          </p>
</div>
</div>
<!-- Prudence : Expert uniquement -->
<div class="row" data-um="expert">
<div>
<label>Mode de prudence</label>
<select id="errMode">
<option value="none">Ne pas corriger</option>
<option selected="" value="conservative">Prudent (on retire X%)</option>
<option value="optimistic">Large (on ajoute X%)</option>
</select>
</div>
</div>
<p class="muted m-02-0">
        La dépense utilisée est ajustée selon ce choix.
      </p>
<div class="row mt-035">
<div class="self-end">
<button id="calcSpendBtn" type="button">Mettre à jour mes objectifs (onglet Repas)</button>
</div>
</div>
<p class="muted" data-um="sport" id="watchNote">
        L’important n’est pas le chiffre du jour, mais la cohérence sur plusieurs jours.
      </p>
</div>
</div>
</section>
<!-- =========================
     OBJECTIF
     ========================= -->
<section class="tabSection" data-tabsection="goal">
<div class="card">
<h2>Répartition protéines / glucides / lipides</h2>
<p class="muted">
      Ici, tu définis <b>comment ton énergie est répartie</b>.
      Certains champs sont à remplir, d’autres se calculent automatiquement.
    </p>
<!-- Régime + objectif -->
<div class="row">
<div>
<label>
          Type de régime (preset)
          <span aria-label="Informations sur l’objectif calorique" class="info-dot" data-modaltext="Choisis une structure de base, tu pourras ajuster ensuite.
Elle fixe des repères automatiques (protéines, lipides minimum, glucides).
Repères :
• Standard : 85%
• Agressif : 75%
• Recomp : 92%
• Maintien : 100%
• Endurance : 95%" role="button" tabindex="0">ℹ️</span>
</label>
<select id="dietMode">
<option selected="" value="none">— Choisir un régime —</option>
<option value="cut_standard">Standard (sportif)</option>
<option value="cut_aggressive">Agressif (court terme)</option>
<option value="recomp">Recomposition (léger déficit)</option>
<option value="maintain">Maintien / équilibre</option>
<option value="endurance">Performance endurance (déficit minime)</option>
<option value="custom">Personnalisé (manuel)</option>
</select>
</div>
<div>
<label>
          Objectif (%)
          <span aria-label="Informations sur l’objectif calorique" class="info-dot" data-modaltext="Equilibre = 100%.
Diminues = tu manges un peu moins que ta dépense.
Augmentes = cas particuliers (ex. recharge, endurance)." role="button" tabindex="0">ℹ️</span>
</label>
<input id="goalPct" max="130" min="60" step="1" type="number" value="0"/>
<div class="muted mt-025">
          Ajuste la <b>quantité totale</b> par rapport à ta dépense du jour.
        </div>
</div>
</div>
<!-- Protéines + lipides + glucides ajustés + ratio -->
<div class="row">
<div>
<label>
          Protéines (g/kg de poids)
          <span aria-label="Informations sur l’objectif calorique" class="info-dot" data-modaltext="Garde-fou : un minimum de protéines ....
Hors mode 'Personnalisé', l'app applique...
Exception : ..." role="button" tabindex="0">ℹ️</span>
</label>
<input id="protPerKg" min="0" step="0.1" type="number" value="0"/>
<div id="protRangeHint">Plage protéines : —</div>
</div>
<!-- Ancien champ lipides (si ton JS l’utilise encore). On le garde. -->
<div hidden="" id="fatPerKgBox">
<label>Lipides (g/kg de poids)</label>
<input id="fatPerKg" min="0.8" step="0.1" type="number" value="0.9"/>
<div id="fatPerKgEffBox" style="display:none">
          Lipides effectifs (après plancher) : <b id="fatPerKgEffTxt">—</b> g/kg
        </div>
</div>
<div>
<label>
          Lipides minimum (g/kg/j)
          <span aria-label="Informations sur l’objectif calorique" class="info-dot" data-modaltext="Un minimum de lipdes est toujours nécessaire et indispensable au bon fonctionnement du corps (hormones, vitamines, récupération).
Hors mode 'Personnalisé',ce minimum est appliqué automatiquement." role="button" tabindex="0">ℹ️</span>
</label>
<input id="fatFloorGPerKg" max="1.0" min="0.6" step="0.1" type="text" inputmode="decimal" pattern="[0-9]*[\.,]?[0-9]+" value="0"/>
<div id="fatRangeHint">Plage lipides : —</div>
</div>


<div>
<label>
          Ratio Glucides / Protéines
          <span aria-label="Informations sur l’objectif calorique" class="info-dot" data-modaltext="Il fixe une relation maximale entre glucides et protéines.
Repères glucidiques OFF : Tu fixes ton ratio C/P pour te donner un repère (ça n’impose rien automatiquement).
Repères glucidiques ON : L’app applique ton ratio comme limite glucides (et ajuste le reste pour rester sur la cible kcal)." role="button" tabindex="0">ℹ️</span>
</label>
<input id="ratioCP" max="2.0" min="0.0" step="0.1" type="number" value="0"/>
<input aria-hidden="true" class="hidden" disabled="" id="ratioCPText" type="text" value="--"/>
<div class="muted 0-25" style="margin-top:.25rem">
          Exemple : 1.0 = autant de glucides que de protéines.
        </div>
</div>

<div>
<div id="carbAutoBox">
<label>
          Glucides ajustés
          <span aria-label="Informations sur l’objectif calorique" class="info-dot" data-modaltext="Les glucides servent à équilibrer la journée.
L’app les ajuste pour rester cohérente avec ton objectif." role="button" tabindex="0">ℹ️</span>
</label>
<input disabled="" id="carbAutoHint" value="Plafond glucidique : —"/>
<div class="muted mt-025">
          Calculés automatiquement selon tes choix précédents (objectif, protéines, lipides).
        </div>
<div aria-live="polite" class="calcPanel mt-025" id="carbCalcPanel">
<div class="calcRow">
<span class="calcLabel">Glucides calculés (avant plafond)</span>
<span class="calcValue"><strong id="carbCalcRawG">—</strong> g</span>
</div>
<div class="calcRow">
<span class="calcLabel">Plafond pris en compte</span>
<span class="calcValue">
<strong id="carbCalcCapG">—</strong> g <span class="muted" id="carbCalcCapKg"></span>
<span class="muted" id="carbCalcCapSrc"></span>
</span>
</div>
<div class="muted" id="carbCalcStatus">—</div>
</div>
</div>
</div>

</div>

<!-- Repères glucidiques (panel) -->
<div class="card panel-subtle">
<h3 class="h3">Repères glucidiques</h3>
<p class="muted">
        Ces repères aident à maintenir une cohérence entre ton objectif et la répartition des apports.
      </p>
<div class="row" style="margin-top:.25rem">
<div>
<label class="muted" style="display:flex; align-items:center; gap:.55rem; user-select:none">
<input id="carbGuardEnabled" type="checkbox"/>
            Activer les repères (option)
          </label>
<div class="muted" style="margin-top:.25rem">
            Quand activés, les glucides sont encadrés et le reste s’ajuste automatiquement pour rester cohérent avec la cible.
          </div>
</div>
<div>
<label class="muted" style="display:flex; align-items:center; gap:.55rem; user-select:none">
<input id="lowCarbEnabled" type="checkbox"/>
            Activer les glucides réduits
          </label>
<div class="muted" style="margin-top:.25rem">
            Les glucides réduits ("Low-Carb") sont sont volontairement bas. Les lipides s’ajustent pour compléter la journée..
          </div>
</div>
</div>
<div class="row" id="lowCarbBox" style="display:none">
<div>
<label>Type low-carb</label>
<select id="lowCarbLevel">
<option value="moderate">Low-Carb modéré (1,5–2,0 g/kg/j)</option>
<option value="strict">Low-Carb strict (0,5–1,0 g/kg/j)</option>
</select>
<div class="muted" style="margin-top:.25rem">Choisis le niveau, puis un palier (g/kg/j).</div>
</div>
<div>
<label>Palier low-carb (g/kg/j)</label>
<input id="lowCarbStep" inputmode="decimal" max="2.0" min="0.5" step="0.1" type="number" value="1.5"/>
<div class="muted" id="lowCarbHelp" style="margin-top:.25rem"></div>
</div>
</div>
<div class="row" id="carbGuardBox" style="display:none">
<div>
<label>
            Objectif (g/kg/j)
            <span aria-label="Informations sur l’objectif calorique" class="info-dot" data-modaltext="Quand les repères sont désactivés, les glucides s’ajustent librement en fonction des autres choix.

L’app propose des options cohérentes avec le régime choisi.

En mode Personnalisé, tu peux ajuster librement.
En mode preset, seules les options compatibles sont proposées." role="button" tabindex="0">ℹ️</span>
</label>
<select id="carbGoal">
<option selected="" value="none">— Choisir un objectif —</option>
<option value="dry_strict">Sèche stricte (2–3 g/kg/j)</option>
<option value="dry_sport">Sèche sportive (3–4 g/kg/j)</option>
<option value="recomp">Recomposition (4–5 g/kg/j)</option>
<option value="maintain_active">Maintien actif (4–6 g/kg/j)</option>
<option value="endurance_volume">Endurance / volume (6–8 g/kg/j)</option>
<option value="carb_loading">Carb-loading (8–12 g/kg/j, 48–72h)</option>
</select>
<div class="muted" id="carbGoalHelp" style="margin-top:.25rem"></div>
</div>
<div>
<label>
            Plafond glucidique
            <span aria-label="Informations sur l’objectif calorique" class="info-dot" data-modaltext="Plafond fixe une limite de glucides pour la journée.
Si elle est atteinte, le reste s’ajuste automatiquement pour rester cohérent.
 
Le plafond glucidique fonctionne par paliers. Chaque pas correspond à 0,1 g/kg, soit environ 50 g de glucides pour un adulte.
 
Tant que le palier n'est pas atteint, le calcul automatique peut ne pas changer visuellement. Le plafond agit uniquement lorsque ce palier est réellement dépassé.." role="button" tabindex="0">ℹ️</span>
</label>
<div class="row" style="gap:.4rem">
<div class="hidden">
<select id="carbStep"></select>
</div>
<div style="min-width:140px">
<input id="carbCapGPerKg" min="0" step="1" type="text" inputmode="decimal" pattern="[0-9]*[\.,]?[0-9]+" value="0">
</div>
</div>
<div class="muted" style="margin-top:.25rem">
            Limite <b>maximale de glucides</b> utilisée quand les repères sont activés.
          </div>
</div>
</div>
</div>
</div><!-- /card principal Objectif -->
<!-- ✅ (déplacé ici) Diabète — raccourcis dans Repas -->
<div aria-live="polite" class="card diab-panel span-2 is-disabled" id="diabPanelInRepas">
<div class="row" style="align-items:flex-end">
<div style="flex:2;min-width:240px">
<h2 style="margin:.1rem 0 .25rem">
          Option diabète — repères glucidiques
          <span class="pill" id="diabQuickStatus">(désactivé)</span>
</h2>
<p class="muted" style="margin:0">
          Ici, tu vois l’essentiel pendant que tu ajoutes tes repas.
        </p>
</div>
</div>
<div class="row mt-04">
<div>
<label>Glucides du jour (g)</label>
<input disabled="" id="diabQuickCarbG" value="-"/>
<div class="muted" style="margin-top:.25rem">
          Total des glucides encodés aujourd’hui.
        </div>
</div>
<div>
<label>
          Dernière glycémie
          <span aria-label="Informations sur l’objectif calorique" class="info-dot" data-modaltext="Ce champ est informatif.
Aucune interprétation médicale n’est faite." role="button" tabindex="0">ℹ️</span>
</label>
<input disabled="" id="diabQuickLastG" value="-"/>
<div class="muted" style="margin-top:.25rem">
          Valeur saisie dans le journal Diabète.
        </div>
</div>
</div>
<div class="mt-06 hidden" id="diabQuickReco">
<div class="noticeTitle" style="margin-bottom:.35rem">Repères utiles</div>
<div class="muted mt-05" id="diabQuickLine">
        Option diabète désactivée : activer pour afficher zones, plafond et alertes.
      </div>
<p class="muted" id="diabQuickRecoText" style="margin:0 0 .5rem"></p>
</div>
</div>
<!-- ✅ Mount point : Résultats dans OBJECTIF -->
<div id="outMountGoal"></div>
</section><!-- /goal -->
<!-- =========================
     REPAS
     ========================= -->
<section class="tabSection" data-tabsection="repas">
<div class="card">
<h2>Repas du jour</h2>
<p class="muted mt-02" id="dietNote">
      Presets = valeurs de départ. Si tu modifies objectif/prot/lip, l’app bascule en “Personnalisé”.
    </p>
<div class="row">
<div class="minw220-flex2">
<label>Nom du repas</label>
<input id="mealName" placeholder="ex: Petit-déj, Pancakes, Collation, Dîner…" type="text"/>
<p class="muted">
          Ajoute tes repas : les totaux se calculent automatiquement.
        </p>
</div>
</div>
<!-- Sous-dashboard MANUEL -->
<div class="card panel-subtle">
<h3>Apport du repas (manuel)</h3>
<p class="muted">Entre directement les valeurs si tu les connais.</p>
<div class="row mt-04">
<div><label>kcal</label><input id="mealK" min="0" step="1" type="number" value="0"/></div>
<div><label>P (g)</label><input id="mealP" min="0" step="0.1" type="number" value="0"/></div>
<div><label>G (g)</label><input id="mealC" min="0" step="0.1" type="number" value="0"/></div>
<div><label>L (g)</label><input id="mealF" min="0" step="0.1" type="number" value="0"/></div>
</div>
<p class="muted mt-02">
        Astuce : l’option /100 g peut remplir ces champs automatiquement.
      </p>
</div>
<!-- Option /100g (expert) -->
<div class="card panel-subtle" data-um="expert">
<h3 data-um="expert">Option rapide /100 g (facultatif)</h3>
<p class="muted" data-um="expert">
        Utilise les valeurs pour 100 g indiquées sur l'emballage.
      </p>
<div class="row mt-04" data-um="expert">
<div>
<label>kcal / 100 g</label>
<input id="qKcal100" min="0" placeholder="ex: 420" step="1" type="number"/>
</div>
<div>
<label>Poids (g)</label>
<input id="qWeight" min="0" placeholder="ex: 35" step="1" type="number"/>
</div>
<div>
<label>P / 100 g</label>
<input id="qP100" min="0" placeholder="optionnel" step="0.1" type="number"/>
</div>
<div>
<label>G / 100 g</label>
<input id="qC100" min="0" placeholder="optionnel" step="0.1" type="number"/>
</div>
<div>
<label>L / 100 g</label>
<input id="qF100" min="0" placeholder="optionnel" step="0.1" type="number"/>
</div>
</div>
<div class="row mt-03" data-um="expert">
<div class="self-end">
<button id="btnApplyPer100" type="button">Remplir à partir de /100 g</button>
</div>
</div>
<p class="muted mt-02" data-um="expert">
        Les valeurs du repas sont calculées automatiquement à partir du poids. Exemple : 35 g à 420 kcal/100 g → clique sur Remplir, puis Ajouter ce repas.
      </p>
</div>
<div class="row">
<div class="self-end">
<button id="btnAddMeal" type="button">Ajouter ce repas (nouvelle ligne)</button>
</div>
<div class="self-end">
<button class="btn-danger" id="btnClearMeals" type="button">Vider la journée</button>
</div>
</div>
<div class="row mt-04" id="mealsTableWrap"></div>
<p class="muted mt-05">Tu peux modifier une cellule directement. Les totaux se mettent à jour automatiquement.</p>
</div><!-- /card Repas -->
<!-- ✅ Mount point : Résultats dans REPAS -->
<div id="outMountRepas"></div>
</section><!-- /repas -->
<!-- ✅ Résultats (unique, monté dynamiquement dans goal/repas via JS) -->
<div class="card hidden" id="out">
<h2>Résultats</h2>
<div class="card panel-subtle">
<h3 class="h3">Déjà consommé aujourd'hui</h3>
<div class="row mt-04">
<div>
<label>Calories (kcal)</label>
<input id="eatenKcal" readonly="" type="number" value="0"/>
</div>
<div>
<label>Protéines (g)</label>
<input id="eatenP" readonly="" type="number" value="0"/>
</div>
<div>
<label>Glucides (g)</label>
<input id="eatenC" readonly="" type="number" value="0"/>
</div>
<div>
<label>Lipides (g)</label>
<input id="eatenF" readonly="" type="number" value="0"/>
</div>
</div>
</div>
<div class="kpi" id="kpis"></div>
<div class="table-wrap">
<table>
<thead>
<tr>
<th></th><th>kcal</th><th>Protéines (g)</th><th>Glucides (g)</th><th>Lipides (g)</th>
</tr>
</thead>
<tbody>
<tr><th>Objectif du jour</th><td id="tK"></td><td id="tP"></td><td id="tC"></td><td id="tF"></td></tr>
<tr><th>Déjà consommé</th><td id="eK"></td><td id="eP2"></td><td id="eC2"></td><td id="eF2"></td></tr>
<tr><th>Reste à consommer</th><td id="rK"></td><td id="rP"></td><td id="rC"></td><td id="rF"></td></tr>
</tbody>
</table>
</div>
<p class="muted" id="notes"></p>
<!-- VIZ — Où vont les calories ? -->
<div class="card" id="calFlowCard">
<h2>Où vont les calories ?</h2>
<p class="muted">
      Les calories sont réparties selon les priorités choisies  : <b>protéines</b>, puis <b>lipides minimum</b>, puis <b>glucides</b>.
      Si un plafond glucidique est actif, l’excédent va vers les lipides.(Tableau détaillé en mode "expert")
    </p>
<div class="grid" data-um="expert">
<div class="flowviz">
<div class="flowgrid">
<div>
<div class="kv">
<div><b>Cible du jour</b></div><div><span id="flow_targetKcal">—</span> kcal</div>
<div>Dépense ajustée</div><div><span id="flow_spendKcal">—</span> kcal</div>
<div>Écart</div><div><span class="pill" id="flow_deltaKcal">—</span></div>
</div>
<div class="grid" style="margin:.55rem 0 .25rem">
<b>Différence entre la dépense ajustée et la cible.</b>
</div>
<div class="barRow">
<div>Protéines</div>
<div class="bar"><i id="barP"></i></div>
<div><span id="flow_pKcal">—</span></div>
</div>
<div class="barRow">
<div>Glucides</div>
<div class="bar"><i id="barC"></i></div>
<div><span id="flow_cKcal">—</span></div>
</div>
<div class="barRow">
<div>Lipides</div>
<div class="bar"><i id="barF"></i></div>
<div><span id="flow_fKcal">—</span></div>
</div>
<div class="muted" style="margin-top:.45rem">
<span class="pill" id="flow_capState">Plafond glucides : —</span>
</div>
</div>
<div>
<div class="grid" style="margin:.1rem 0 .35rem"><b>Repères en grammes (rappel)</b></div>
<div class="kv">
<div>Protéines</div><div><span id="flow_pG">—</span> g</div>
<div>Glucides</div><div><span id="flow_cG">—</span> g</div>
<div>Lipides (final)</div><div><span id="flow_fG">—</span> g</div>
</div>
<div class="grid" style="margin:.6rem 0 .35rem"><b>Détails avancés</b></div>
<div class="kv">
<div>Cap glucides</div><div><span id="flow_capG">—</span></div>
<div>Glucides “théoriques” sans plafond</div><div><span id="flow_cTheoG">—</span> g</div>
<div>Calories déplacées</div><div><span id="flow_shiftKcal">—</span> kcal</div>
<div>Lipides minimum</div><div><span id="flow_fBaseG">—</span> g</div>
<div>Lipides ajoutés</div><div><span id="flow_fExtraG">—</span> g</div>
</div>
</div>
</div>
<details>
<summary class="muted cursor-pointer">Comment lire ce panneau</summary>
<div class="muted mt-035">
<b>1)</b>Les protéines sont fixées en priorité.<br/>
<b>2)</b>Un minimum de lipides est garanti.<br/>
<b>3)</b>Le reste complète avec les glucides.<br/>
<b>4)</b>Si un plafond est actif, l’excédent va vers les lipides.
          </div>
</details>
</div>
</div>
</div>
</div><!-- /out -->
<!-- =========================
         JOURNAL
         ========================= -->
<section class="tabSection" data-tabsection="journal">
<!-- Suivi poids & compo : Sport + Expert -->
<div class="card mt-06" data-um="sport">
<h2>Sport &amp; sommeil (journal local)</h2>
<div class="muted">But : contextualiser tes macros avec 2–3 signaux simples (sans automatisme caché).</div>
<div class="row mt-06">
<div>
<label>Sport — durée (min)</label>
<input id="sportMin" min="0" step="5" type="number" value="0"/>
</div>
<div>
<label>Sport — kcal / charge</label>
<input id="sportKcal" min="0" step="10" type="number" value="0"/>
</div>
<div>
<label>Sport — type (optionnel)</label>
<input id="sportType" placeholder="Trail, muscu, padel…" type="text"/>
</div>
</div>
<div class="row mt-06">
<div>
<label>Sommeil — durée (h)</label>
<input id="sleepH" min="0" step="0.25" type="number" value="0"/>
</div>
<div>
<label>Sommeil — score (optionnel)</label>
<input id="sleepScore" max="100" min="0" step="1" type="number" value="0"/>
</div>
<div>
<label>Coucher / lever (optionnel)</label>
<div class="grid" style="gap:.5rem">
<input id="sleepBed" type="time"/>
<input id="sleepWake" type="time"/>
</div>
</div>
</div>
<div class="mt-06" id="sportSleep7d"></div>
</div>
<div class="card">
<h2>Historique (stocké localement)</h2>
<div class="row">
<div>
<label>Poids (mesure standardisée)</label>
<input id="morningWeight" min="0" placeholder="ex: 83.6" step="0.1" type="number"/>
<div class="muted" style="margin-top:.25rem">
Idéalement mesuré dans des conditions similaires (heure, tenue, balance).
          </div>
</div>
<div>
<label>Moyenne 7 jours (auto)</label>
<input disabled="" id="avg7Weight" value="-"/>
<div class="muted" style="margin-top:.25rem">
Lisse les variations quotidiennes.
          </div>
</div>
<div>
<label>Variation hebdomadaire</label>
<input disabled="" id="wkVarPct" value="-"/>
<div class="muted" style="margin-top:.25rem">
Évolution estimée par rapport à la semaine précédente.
          </div>
</div>
</div>
<div class="row">
<div>
<label>Masse grasse (%)</label>
<input id="fatPct" min="0" placeholder="ex: 18.5" step="0.1" type="number"/>
</div>
<div>
<label>Masse musculaire (%)</label>
<input id="musclePct" min="0" placeholder="ex: 42.0" step="0.1" type="number"/>
</div>
<div>
<label>Masse osseuse (kg)</label>
<input id="boneKg" min="0" placeholder="ex: 3.2" step="0.1" type="number"/>
</div>
</div>
<div class="row">
<div>
<label>IMC<span aria-label="Informations sur l’objectif calorique" class="info-dot" data-modaltext="Indice de Masse Corporelle : IMC = poids / taille².
 Poids utilisé = poids mesuré si encodé, sinon poids “profil”.
L’IMC ne distingue pas masse musculaire et masse grasse." role="button" tabindex="0">ℹ️</span></label>
<input disabled="" id="bmiVal" value="-"/>
</div>
<div>
<label>Catégorie IMC (indicatif)</label>
<input disabled="" id="bmiCat" value="-"/>
<div class="muted" style="margin-top:.25rem">
Classement standard basé sur le poids et la taille.
          </div>
</div>
<div>
<label>Poids utilisé pour l'IMC</label>
<input disabled="" id="bmiWeightUsed" value="-"/>
<div class="muted" style="margin-top:.25rem">
Poids mesuré du jour, ou poids de référence si non encodé.
          </div>
</div>
</div>
<!-- Tendance 7 jours : Expert uniquement -->
<div class="card my06-p08" data-um="expert">
<h3>Tendance 7 jours (Expert)</h3>
<div class="row">
<div>
<label>Dépense moyenne (7 jours)</label>
<input disabled="" id="avg7SpendKcal" value="-"/>
<div class="muted" style="margin-top:.25rem">
Basée sur les estimations de la montre.
          </div>
</div>
<div>
<label>Consommation moyenne (7 jours)</label>
<input disabled="" id="avg7EatKcal" value="-"/>
<div class="muted" style="margin-top:.25rem">
Dépend des repas réellement encodés.
          </div>
</div>
<div>
<label>Écart moyen estimé</label>
<input disabled="" id="avg7DefKcal" value="-"/>
<div class="muted" style="margin-top:.25rem">
Différence moyenne entre dépense et consommation.
          </div>
</div>
</div>
<div class="row">
<div>
<label>Projection hebdo— ordre de grandeur</label>
<input disabled="" id="projWkKg" value="-"/>
<div class="muted" style="margin-top:.25rem">
Projection théorique basée sur l’écart moyen.
          </div>
</div>
<div>
<label>Poids observé vs tendance estimée</label>
<input disabled="" id="deltaRealVsTheo" value="-"/>
<div class="muted" style="margin-top:.25rem">
Comparaison indicative sur 7 jours.
          </div>
</div>
<div>
<label>Qualité des données (7 jours)</label>
<input disabled="" id="dataQuality7" value="-"/>
<div class="muted" style="margin-top:.25rem">
Plus il y a de jours complets, plus la tendance est fiable.
          </div>
</div>
</div>
<p class="muted mt-04" id="trend7Note">-</p>
</div>
</div>
<!-- Historique : visible pour tous -->
<div class="card">
<h2>Historique des journées (stocké localement)</h2>
<div class="row">
<div>
<label>Choisir une date</label>
<input id="dayDate" type="date"/>
</div>
<div class="self-end">
<button id="calcBtn" type="button">Recalculer la journée</button>
</div>
<div class="self-end">
<button class="btn-danger" id="btnDeleteDay" type="button">Supprimer TOUT l'historique</button>
</div>
</div>
<div class="muted mt-06" id="daysHistory"></div>
<div class="card mt-06" id="diabHistoryCard">
<h2 style="margin:.1rem 0 .6rem">Historique journée — option diabète</h2>
<div class="muted" style="margin-top:.15rem">
            Synthèse par journée : glucides consommés et relevés glycémiques.
Visible uniquement si l’option diabète est activée.
          </div>
<!-- Message quand le mode diabète est OFF -->
<div class="muted diab-lockmsg" id="diabHistoryLockMsg">
            Option diabète désactivée : active-la pour afficher l’historique diabète.
          </div>
<!-- Contenu verrouillable (OFF => grisé + non cliquable) -->
<div class="mt-06 diab-locked" id="diabHistoryBody">
<div class="row">
<div>
<label>Choisir une date</label>
<input id="diabHistDate" type="date"/>
</div>
<div class="self-end">
<button id="btnDiabHistRefresh" type="button">Recalculer la journée diabète</button>
</div>
<div class="self-end">
<button class="btn-danger" id="btnDiabDeleteDay" type="button">Supprimer TOUT l'historique diabète</button>
</div>
</div>
<div class="mt-06" id="diab_daysHistory_suivi"></div>
</div>
</div>
</div>
</section>
<!-- =========================
         DIABÈTE
         ========================= -->
<section class="tabSection" data-tabsection="diab">
<div class="card">
<p class="muted" style="margin-top:-.2rem">
        Suivi personnel (local). Aucun calcul de dose/ajustement thérapeutique.
        </p>
<div class="grid">
<div class="card">
<h2>Diabète — journée</h2>
<div class="row" style="margin-top:.35rem">
<div>
<label>Activité (résumé)<span aria-label="Informations sur l’objectif calorique" class="info-dot" data-modaltext="..." role="button" tabindex="0">ℹ️</span></label>
<input id="diab_dayActivity" placeholder="ex: tennis 1h30 + marche 6k pas" type="text"/>
</div>
<div>
<label>
          Stress (0–10)
          <span class="info-dot" title="Auto-évaluation simple (pas médical).">?</span>
</label>
<input id="diab_dayStress" max="10" min="0" placeholder="ex: 6" step="1" type="number"/>
</div>
<div>
<label>
          Sommeil (heures)
          <span class="info-dot" title="Durée totale approximative.">?</span>
</label>
<input id="diab_daySleepH" max="24" min="0" placeholder="ex: 6.5" step="0.1" type="number"/>
</div>
</div>
<div class="row" style="margin-top:.35rem">
<div>
<label>
          Infection / maladie ?
          <span class="info-dot" title="Oui/non — pour contextualiser les variations de glycémie.">?</span>
</label>
<select id="diab_daySick">
<option selected="" value="">(non renseigné)</option>
<option value="no">Non</option>
<option value="yes">Oui</option>
</select>
</div>
<div>
<label>
          Alcool ?
          <span class="info-dot" title="Oui/non — pour contextualiser la journée.">?</span>
</label>
<select id="diab_dayAlcohol">
<option selected="" value="">(non renseigné)</option>
<option value="no">Non</option>
<option value="yes">Oui</option>
</select>
</div>
<div style="flex:2;min-width:260px">
<label>Note journée (optionnel)</label>
<input id="diab_dayNoteFree" placeholder="ex: resto, déplacement, nuit courte…" type="text"/>
</div>
</div>
<div class="hidden" style="margin-top:.35rem">
<div style="align-self:flex-end">
<button id="diab_btnSaveDayMeta" type="button">Rafraîchir (glucides)</button>
</div>
</div>
</div>
<div class="card">
<h2 style="margin:.1rem 0 .6rem">Diabète — glycémies (journal)</h2>
<p class="muted" style="margin-top:-.2rem">
       Tout est stocké localement (dans ton navigateur). Conversion mg/dL↔mmol/L : affichage (stockage interne en mg/dL)
    </p>
<div class="kpi" id="diab_dayKpis" style="align-self:flex-end"></div>
<p class="muted" id="diab_dayNote"></p>
<div class="row">
<div>
<label>Valeur</label>
<input id="diab_gValue" min="0" placeholder="ex: 108 (mg/dL) ou 6.0 (mmol/L)" step="0.1" type="number"/>
</div>
<div class="row">
<div>
<label>
      Unité glycémie
      <span class="info-dot" title="mg/dL ↔ mmol/L (conversion d'affichage).">?</span>
</label>
<select id="diab_glucoseUnit">
<option selected="" value="mgdl">mg/dL</option>
<option value="mmol">mmol/L</option>
</select>
</div>
</div>
<!-- garder l'input existant en “compat” mais invisible si tu veux éviter de casser des refs -->
<input class="hidden" id="diab_carbPortionG" type="number" value="15"/>
<div>
<label>Moment</label>
<select id="diab_gContext">
<option selected="" value="à jeun">à jeun</option>
<option value="avant repas">avant repas</option>
<option value="2h après repas">2h après repas</option>
<option value="coucher">coucher</option>
<option value="nuit / réveil hypo">nuit / réveil hypo</option>
<option value="avant sport">avant sport</option>
<option value="après sport">après sport</option>
<option value="autre">autre</option>
</select>
</div>
<div>
<label>Heure (optionnel)</label>
<input id="diab_gTime" type="time"/>
</div>
</div>
<div class="row">
<div style="flex:2;min-width:260px">
<label>Note (optionnel)</label>
<input id="diab_gNote" placeholder="ex: stress, repas riche, symptômes…" type="text"/>
</div>
<div class="row">
<label>
      HbA1c (%) (labo)
      <span class="info-dot" title="Indicateur labo (tendance sur ~2–3 mois). Informatif uniquement.">?</span>
</label>
<input id="diab_hba1c" max="20" min="3" placeholder="ex: 6.4" step="0.1" type="number"/>
</div>
<div class="row">
<label>Date labo</label>
<input id="diab_hba1cDate" type="date"/>
</div>
<div style="align-self:flex-end">
<button id="diab_btnAddGlucose" type="button">Ajouter mesure</button>
</div>
<div style="align-self:flex-end">
<button class="btn-danger" id="diab_btnClearGlucose" type="button">Vider glycémies du jour</button>
</div>
</div>
<div id="diab_glucoseTableWrap"></div>
<p class="muted" style="margin-top:.45rem">Tu peux éditer directement une cellule.</p>
</div>
</div>
<div id="diabBlocksHome"></div>
<div id="diabBlocksWrap">
<div class="card">
<h2 style="margin:.1rem 0 .6rem">Diabète — repas (glucides)</h2>
<div class="row">
<div><label>Nom</label><input id="diab_mealName" placeholder="ex: Petit-déj" type="text"/></div>
<div><label>Glucides (g)</label><input id="diab_mealCarb" min="0" step="0.1" type="number" value="0"/></div>
</div>
<div class="row">
<div style="flex:2;min-width:260px"><label>Note</label><input id="diab_mealNote" placeholder="optionnel" type="text"/></div>
<div style="align-self:flex-end"><button id="diab_btnAddMeal" type="button">Ajouter ce repas</button></div>
<div style="align-self:flex-end"><button class="btn-danger" id="diab_btnClearMeals" type="button">Vider repas du jour</button></div>
</div>
<h3 class="muted" style="margin:.7rem 0 .35rem">Calcul “au 100 g” (optionnel)</h3>
<div class="row">
<div><label>Poids (g)</label><input id="diab_qWeight" min="0" step="1" type="number" value="0"/></div>
<div><label>Glucides /100g</label><input id="diab_qC100" min="0" step="0.1" type="number" value="0"/></div>
<div style="align-self:flex-end"><button id="diab_btnApplyPer100" type="button">Appliquer → repas</button></div>
</div>
<div id="diab_mealsTableWrap"></div>
</div>
<div class="card">
<h2 style="margin:.1rem 0 .6rem">Diabète — historique</h2>
<div id="diab_daysHistory"></div>
</div></div>
</div>
</section>
<!-- =========================
     CLOUD
     ========================= -->
<section class="tabSection" data-tabsection="cloud">
<div class="card" id="cloudCard">
<h2>Compte &amp; synchronisation (optionnelle)</h2>
<p class="muted">
      Tu restes toujours propriétaire de tes données.
      Aucune sauvegarde n’est automatique.
    </p>
<div class="row">
<div class="minw240-flex2">
<label>Email (optionnel)</label>
<input id="cloudEmail" placeholder="ex: toi@email.com" type="email"/>
<div class="muted mt-025">
          Sans email, les données restent stockées uniquement sur cet appareil.
        </div>
</div>
<div class="self-end">
<button id="btnCloudLogin" type="button">Recevoir un lien</button>
</div>
<div class="self-end">
<button id="btnCloudLogout" type="button">Se déconnecter</button>
</div>
</div>
<div class="row mt-03">
<div class="self-end">
<button id="btnCloudPull" type="button">Récupérer depuis le cloud</button>
</div>
<div class="self-end">
<button id="btnCloudPush" type="button">Sauvegarder vers le cloud</button>
</div>
<div class="self-end">
<button id="btnCloudSync" type="button">Synchroniser automatiquement</button>
</div>
</div>
<p class="muted mt-045" id="cloudStatus">Statut : non connecté</p>
<details class="mt-04">
<summary class="muted cursor-pointer">Comment ça marche</summary>
<div class="muted mt-04">
        Sans email : tout reste en local.<br/>
        Avec email : tu peux sauvegarder ou récupérer tes données.<br/>
        La synchronisation est toujours manuelle ou déclenchée par toi.
      </div>
</details>
<!-- Sauvegarde manuelle (offline) — Expert uniquement -->
<details class="mt-06" data-um="expert">
<summary class="muted cursor-pointer">Sauvegarde manuelle (hors ligne)</summary>
<div class="muted mt-04">
        En l’absence de cloud ou de réseau, tu peux exporter tes données et les importer ailleurs.
        Cette option est réservée aux utilisateurs avancés.
      </div>
<div class="row mt-05">
<div class="self-end">
<button id="btnExportDays" type="button">Exporter JSON</button>
</div>
<div class="self-end">
<button id="btnImportDays" type="button">Importer JSON</button>
</div>
<div class="self-end">
<button class="btn-danger" id="btnClearDays" type="button">Tout effacer (profil)</button>
</div>
</div>
<textarea class="mt-055" id="daysJsonBox" placeholder="JSON ici (export/import)…"></textarea>
<div class="muted mt-035">
        Astuce : tu peux envoyer ce JSON sur un autre appareil, puis le coller ici et cliquer “Importer”.
      </div>
</details>
</div>
</section>
<!-- Modal (global) -->
<div aria-hidden="true" class="modal" id="watchInfoModal">
<div class="modal__backdrop" data-close="1"></div>
<div aria-labelledby="watchInfoTitle" aria-modal="true" class="modal__panel" role="dialog">
<div class="modal__head">
<div class="modal__title" id="watchInfoTitle">Informations</div>
<button aria-label="Fermer" class="modal__close" id="watchInfoClose" type="button">✕</button>
</div>
<div class="modal__body" id="watchInfoBody"></div>
<div class="modal__foot">
<button id="watchInfoOk" type="button">OK</button>
</div>
</div>
</div>
<!-- =========================
     LEXICON
     ========================= -->
<section class="tabSection" data-tabsection="lexicon">
<div class="card">
<h2>Lexique</h2>
<p class="muted">
      Ce lexique explique les termes utilisés dans l’application.
      Les définitions sont données à titre de <b>repères de compréhension</b>,
      pas de recommandations médicales.
    </p>
<!-- 🔋 ÉNERGIE & CALORIES -->
<div class="notice notice--warn mt-06">
<div class="noticeTitle">Énergie &amp; calories</div>
<h4>Calorie (kcal)</h4>
<p class="muted">
        Dans l’application, la calorie est une unité de repère utilisée pour estimer
        l’énergie apportée par l’alimentation et dépensée dans la journée.
        Ce n’est pas une mesure exacte du corps humain.
        Elle sert à comparer les journées entre elles et à garder une cohérence globale.
      </p>
<h4>BMR (métabolisme de base)</h4>
<p class="muted">
        Dans l’application, le BMR représente une estimation de l’énergie minimale
        dépensée au repos.
        Ce n’est pas un objectif alimentaire ni une dépense journalière.
        Il sert uniquement de repère pour éviter des objectifs trop bas.
      </p>
</div>
<!-- 🍽️ MACROS & NUTRITION -->
<div class="notice notice--ok mt-06">
<div class="noticeTitle">Macros &amp; nutrition</div>
<h4>Protéines</h4>
<p class="muted">
        Dans l’application, les protéines sont un repère nutritionnel prioritaire
        dans la répartition des apports.
        Elles ne constituent pas une prescription individuelle.
        Elles servent à structurer les repas et la récupération.
      </p>
<h4>Glucides</h4>
<p class="muted">
        Dans l’application, les glucides sont un levier d’ajustement énergétique
        selon l’objectif et l’activité.
        Ils ne sont ni bons ni mauvais en soi.
        Ils aident à adapter l’alimentation au rythme quotidien.
      </p>
<h4>Lipides</h4>
<p class="muted">
        Dans l’application, les lipides sont un apport indispensable intégré
        à la répartition globale.
        Ils ne doivent pas être supprimés ni sur-interprétés.
        Ils participent à l’équilibre énergétique.
      </p>
<h4>Ratio glucides / protéines</h4>
<p class="muted">
        Dans l’application, ce ratio est un repère optionnel qui limite la place
        des glucides par rapport aux protéines.
        Il ne définit pas un équilibre nutritionnel universel.
        Il aide à structurer certaines journées.
      </p>
<h4>Lipides minimum</h4>
<p class="muted">
        Dans l’application, les lipides minimum correspondent à un seuil
        de sécurité nutritionnelle.
        Ce n’est pas une recommandation médicale personnalisée.
        Ils garantissent une base stable lorsque les glucides sont réduits.
      </p>
<h4>Repères glucidiques</h4>
<p class="muted">
        Dans l’application, les repères glucidiques sont des limites de cohérence
        optionnelles.
        Ils ne sont ni obligatoires ni bloquants.
        Ils servent à mieux visualiser et encadrer les glucides.
      </p>
<h4>Low-carb (mode)</h4>
<p class="muted">
        Dans l’application, le mode low-carb correspond à une organisation
        volontairement basse en glucides.
        Ce n’est ni un régime médical ni une obligation.
        Il permet d’explorer une répartition différente selon le contexte.
      </p>
</div>
<!-- 📊 SUIVI & TENDANCES -->
<div class="notice notice--warn mt-06">
<div class="noticeTitle">Suivi &amp; tendances</div>
<h4>Masse grasse (%)</h4>
<p class="muted">
        Dans l’application, la masse grasse est une valeur indicative fournie
        par la balance.
        Elle ne reflète pas précisément la composition corporelle réelle.
        Elle se lit surtout dans le temps.
      </p>
<h4>Masse musculaire (%)</h4>
<p class="muted">
        Dans l’application, la masse musculaire est une estimation dépendante
        de l’appareil utilisé.
        Elle ne mesure pas la performance.
        Elle sert à observer des tendances.
      </p>
<h4>Masse osseuse (kg)</h4>
<p class="muted">
        Dans l’application, la masse osseuse est une valeur approximative issue
        des balances connectées.
        Elle n’a pas de portée diagnostique.
        Elle reste généralement stable dans le temps.
      </p>
<h4>IMC</h4>
<p class="muted">
        Dans l’application, l’IMC est un indice standard basé sur le poids et la taille.
        Il ne distingue pas masse musculaire et masse grasse.
        Il est fourni comme repère général.
      </p>
<h4>Catégorie IMC (indicatif)</h4>
<p class="muted">
        Dans l’application, la catégorie IMC est une classification automatique
        et indicative.
        Elle ne reflète pas l’état de santé individuel.
        Elle sert uniquement de lecture standardisée.
      </p>
</div>
<!-- 🩸 MODE DIABÈTE -->
<div class="notice notice--ok mt-06">
<div class="noticeTitle">Mode diabète (si activé)</div>
<h4>Mode diabète (dans l’application)</h4>
<p class="muted">
        Dans l’application, le mode diabète active un journal de suivi personnel.
        Il ne remplace pas un suivi médical ni un traitement.
        Il aide à observer des liens entre alimentation, glycémies et contexte.
      </p>
<h4>Glycémie et unités</h4>
<p class="muted">
        Dans l’application, la glycémie correspond aux valeurs mesurées
        par l’utilisateur, dans les unités de son choix.
        L’application n’interprète pas ces valeurs.
        Elles servent uniquement au suivi personnel.
      </p>
<h4>Journal glycémique</h4>
<p class="muted">
        Dans l’application, le journal glycémique regroupe les mesures et le contexte.
        Il ne permet aucune prédiction.
        Il aide à visualiser des tendances.
      </p>
<h4>Glucides du jour</h4>
<p class="muted">
        Dans l’application, les glucides du jour représentent le total encodé.
        Ils ne constituent pas une limite médicale.
        Ils servent de repère visuel pendant la journée.
      </p>
<h4>Repères glucidiques (diabète)</h4>
<p class="muted">
        Dans l’application, ces repères servent à structurer la lecture des glucides.
        Ils n’ont aucune valeur thérapeutique.
        Ils facilitent l’observation des effets alimentaires.
      </p>
<h4>Low-carb (diabète)</h4>
<p class="muted">
        Dans l’application, le low-carb en mode diabète est une organisation volontaire.
        Il ne remplace aucun traitement.
        Il sert uniquement à explorer des variations personnelles.
      </p>
</div>
<!-- 🧩 COMBINAISONS & USAGES -->
<div class="notice notice--warn mt-06">
<div class="noticeTitle">Combinaisons &amp; usages</div>
<h4>Régime standard</h4>
<p class="muted">
        Dans l’application, le régime standard correspond à une répartition équilibrée
        et souple.
        Ce n’est pas un modèle universel.
        Il favorise la simplicité au quotidien.
      </p>
<h4>Régime sportif</h4>
<p class="muted">
        Dans l’application, le régime sportif donne plus de place à l’énergie disponible.
        Il ne garantit pas la performance.
        Il accompagne les journées actives.
      </p>
<h4>Régime déficit</h4>
<p class="muted">
        Dans l’application, le régime déficit réduit la cible calorique globale.
        Il ne définit pas un rythme de perte de poids.
        Il structure une phase de réduction progressive.
      </p>
<h4>Objectif (%)</h4>
<p class="muted">
        Dans l’application, l’objectif ajuste la quantité totale d’énergie visée.
        Il ne correspond pas à un résultat garanti.
        Il s’adapte au contexte de la journée.
      </p>
<h4>Scénarios d’usage</h4>
<p class="muted">
        Dans l’application, les scénarios d’usage décrivent des configurations courantes.
        Ils ne sont ni des conseils ni des parcours imposés.
        Ils servent de repères de compréhension.
      </p>
<h4>Mode Expert</h4>
<p class="muted">
        Dans l’application, le mode Expert affiche des détails avancés.
        Il n’oblige pas à optimiser ni à comprendre tous les calculs.
        Il s’adresse aux utilisateurs curieux.
      </p>
</div>
<!-- ⌚ MONTRE & AJUSTEMENTS (Expert) -->
<div class="notice notice--ok mt-06" data-um="expert">
<div class="noticeTitle">Montre &amp; ajustements (optionnel)</div>
<h4>Incertitude (%)</h4>
<p class="muted">
        Dans l’application, l’incertitude représente une marge appliquée
        à l’estimation de la montre.
        Elle ne corrige pas la réalité biologique.
        Elle évite une confiance excessive dans un chiffre unique.
      </p>
<h4>Mode prudent</h4>
<p class="muted">
        Dans l’application, le mode prudent applique une correction conservatrice.
        Il ne protège pas de tous les écarts.
        Il favorise une approche plus sécurisée.
      </p>
<h4>Mode large</h4>
<p class="muted">
        Dans l’application, le mode large autorise une estimation plus permissive.
        Il ne garantit pas l’exactitude.
        Il s’utilise dans des contextes spécifiques.
      </p>
<h4>Dépense ajustée</h4>
<p class="muted">
        Dans l’application, la dépense ajustée est la base de calcul utilisée.
        Elle reste une approximation.
        Elle sert de repère central pour la journée.
      </p>
<h4>Dépense utilisée</h4>
<p class="muted">
        Dans l’application, la dépense utilisée correspond à la valeur prise
        en compte dans les calculs.
        Elle ne représente pas la dépense réelle du corps.
        Elle garantit la cohérence interne.
      </p>
</div>
<!-- 🧩 SCÉNARIOS D’USAGE (Expert) -->
<div class="notice notice--ok mt-06" data-um="expert">
<div class="noticeTitle">Scénarios d’usage (8)</div>
<p class="muted">
        Ces scénarios décrivent des <b>usages courants</b> de l’application.
        Ce sont des <b>repères de compréhension</b>, pas des recommandations personnalisées.
      </p>
<details class="mt-025">
<summary><b>1) Suivi libre et flexible</b> (équilibre quotidien)</summary>
<div class="muted mt-025">
<b>Configuration typique</b><br/>
          • Régime : standard / équilibre<br/>
          • Repères glucidiques : désactivés<br/>
          • Low-carb : désactivé<br/>
          • Objectif : ~100 %<br/><br/>
<b>Ce que fait l’app</b><br/>
          • Les glucides complètent automatiquement les calories restantes.<br/>
          • Les lipides restent au niveau de base du régime.<br/><br/>
<b>Usage courant</b><br/>
          • Journées variées, activité modérée<br/>
          • Recherche de simplicité et de flexibilité
        </div>
</details>
<details class="mt-025">
<summary><b>2) Suivi structuré sans restriction forte</b></summary>
<div class="muted mt-025">
<b>Configuration typique</b><br/>
          • Régime : standard / sportif<br/>
          • Repères glucidiques : activés<br/>
          • Low-carb : désactivé<br/>
          • Objectif : 90–100 %<br/><br/>
<b>Ce que fait l’app</b><br/>
          • Les glucides sont encadrés par un repère.<br/>
          • Si un plafond est atteint, le reste s’ajuste automatiquement.<br/><br/>
<b>Usage courant</b><br/>
          • Meilleure lisibilité des glucides<br/>
          • Activité sportive régulière, besoin de cadre sans rigidité
        </div>
</details>
<details class="mt-025">
<summary><b>3) Réduction calorique progressive</b></summary>
<div class="muted mt-025">
<b>Configuration typique</b><br/>
          • Régime : déficit / recomposition<br/>
          • Repères glucidiques : parfois activés<br/>
          • Low-carb : désactivé<br/>
          • Objectif : &lt; 100 %<br/><br/>
<b>Ce que fait l’app</b><br/>
          • La cible calorique diminue.<br/>
          • Les protéines et les lipides minimum restent prioritaires.<br/><br/>
<b>Usage courant</b><br/>
          • Déficit modéré sur plusieurs semaines<br/>
          • Attention portée à la récupération et à la régularité
        </div>
</details>
<details class="mt-025">
<summary><b>4) Low-carb explicite</b> (quotidien calme)</summary>
<div class="muted mt-025">
<b>Configuration typique</b><br/>
          • Low-carb : activé<br/>
          • Repères glucidiques : activés<br/>
          • Régime : compatible lipides plus élevés<br/>
          • Objectif : variable<br/><br/>
<b>Ce que fait l’app</b><br/>
          • Les glucides sont volontairement limités.<br/>
          • Les lipides s’ajustent pour compléter la journée.<br/><br/>
<b>Usage courant</b><br/>
          • Journées à faible charge glycémique<br/>
          • Sensibilité personnelle aux glucides, peu d’entraînement intense
        </div>
</details>
<details class="mt-025">
<summary><b>5) Journée sportive / entraînement</b></summary>
<div class="muted mt-025">
<b>Configuration typique</b><br/>
          • Régime : sportif / endurance<br/>
          • Repères glucidiques : désactivés (souvent)<br/>
          • Low-carb : désactivé<br/>
          • Objectif : 95–105 %<br/><br/>
<b>Ce que fait l’app</b><br/>
          • La cible suit la dépense estimée du jour.<br/>
          • Les glucides prennent plus de place dans la répartition.<br/><br/>
<b>Usage courant</b><br/>
          • Entraînement soutenu<br/>
          • Recherche de maintien ou de performance
        </div>
</details>
<details class="mt-025">
<summary><b>6) Alternance jours ON / jours OFF</b></summary>
<div class="muted mt-025">
<b>Configuration typique</b><br/>
          • Réglages ajustés selon la journée<br/>
          • Repères glucidiques : variables<br/>
          • Objectif : variable<br/><br/>
<b>Ce que fait l’app</b><br/>
          • La répartition s’adapte aux choix du jour.<br/>
          • La lecture se fait surtout sur plusieurs jours (tendances).<br/><br/>
<b>Usage courant</b><br/>
          • Organisation semaine / week-end<br/>
          • Alternance sport / repos, recherche de cohérence globale
        </div>
</details>
<details class="mt-025">
<summary><b>7) Suivi glycémique</b> (mode diabète)</summary>
<div class="muted mt-025">
<b>Configuration typique</b><br/>
          • Mode diabète : activé<br/>
          • Repères glucidiques : souvent activés<br/>
          • Low-carb : selon préférence personnelle<br/><br/>
<b>Ce que fait l’app</b><br/>
          • Les glucides du jour sont visibles en continu.<br/>
          • Les glycémies et notes sont journalisées.<br/><br/>
<b>Usage courant</b><br/>
          • Observation des réactions individuelles<br/>
          • Mise en lien alimentation / glycémies / contexte (non médical)
        </div>
</details>
<details class="mt-025">
<summary><b>8) Analyse avancée</b> (mode Expert)</summary>
<div class="muted mt-025">
<b>Configuration typique</b><br/>
          • Mode Expert : activé<br/>
          • Détails avancés visibles<br/><br/>
<b>Ce que fait l’app</b><br/>
          • Affiche la logique de répartition et des détails de calcul.<br/>
          • Facilite la lecture fine des écarts et tendances.<br/><br/>
<b>Usage courant</b><br/>
          • Utilisateurs expérimentés ou curieux<br/>
          • Analyse et compréhension, sans obligation d’optimiser
        </div>
</details>
</div>
</div>
</section>
<!-- Scripts -->
<script>
/* =====================================================================
   ✅ STRUCTURE (copie-colle) : “qui pilote quoi”
   Objectif : que tu voies immédiatement quel UI (div/id/class/button)
   est piloté par quelle fonction, et où ranger tes blocs.
   ===================================================================== */

/* =========================
   0) DOM MAP (référence unique)
   ========================= */
const DOM_MAP = {
  // --- CGU / verrouillage ---
  terms: {
    checkbox: "#ackTerms",
    allowTab: "welcome",
    lockClass: "html.app-locked",
    lockTargets: [".tabBtn", ".menuItem"]
  },

  // --- Navigation / tabs / menu mobile ---
  nav: {
    menuBtn: "#menuBtn",
    menuPanel: "#menuPanel",
    menuItems: ".menuItem[data-tab]",
    tabBtns: ".tabBtn[data-tab]",
    sections: ".tabSection[data-tabsection]"
  },

  // --- Profil ---
  profile: {
    select: "#profileSelect",
    name: "#profileName",
    btnCreate: "#btnCreateProfile",
    btnDelete: "#btnDeleteProfile"
  },

  // --- Inputs “profil & calcul” ---
  inputs: {
    date: "#dayDate",
    sex: "#sex", age:"#age", height:"#height", weight:"#weight",
    montre:"#montre", watchBrand:"#watchBrand", errPct:"#errPct", errMode:"#errMode",
    dietMode:"#dietMode", goalPct:"#goalPct", protPerKg:"#protPerKg", fatPerKg:"#fatPerKg",
    useMode:"#useMode"
  },

  // --- Repères glucidiques / low-carb ---
  carb: {
    enabledGuard:"#carbGuardEnabled",
    enabledLow:"#lowCarbEnabled",
    goal:"#carbGoal",
    step:"#carbStep",
    cap:"#carbCapGPerKg",
    ratio:"#ratioCP",
    explain:"#carbGuardExplain",
    goalHelp:"#carbGoalHelp",
    carbAutoHint:"#carbAutoHint",
    lowLevel:"#lowCarbLevel",
    lowStep:"#lowCarbStep",
    lowBox:"#lowCarbBox",
    fatFloor:"#fatFloorGPerKg",
    fatFloorExplain:"#fatFloorExplain",
    fatRangeHint:"#fatRangeHint",
    protRangeHint:"#protRangeHint"
  },

  // --- Repas du jour ---
  meals: {
    wrap:"#mealsTableWrap",
    name:"#mealName", k:"#mealK", p:"#mealP", c:"#mealC", f:"#mealF",
    btnAdd:"#btnAddMeal",
    btnClear:"#btnClearMeals",
    per100: { btn:"#btnApplyPer100", qKcal:"#qKcal100", qW:"#qWeight", qP:"#qP100", qC:"#qC100", qF:"#qF100" }
  },

  // --- Sorties / résultats / KPI ---
  out: {
    out:"#out",
    kpis:"#kpis",
    t:"#tK,#tP,#tC,#tF",
    e:"#eK,#eP2,#eC2,#eF2",
    r:"#rK,#rP,#rC,#rF",
    notes:"#notes"
  },

  // --- Historique ---
  history: {
    days:"#daysHistory",
    btnDeleteAll:"#btnDeleteDay",
    btnExport:"#btnExportDays",
    btnImport:"#btnImportDays",
    btnClear:"#btnClearDays",
    jsonBox:"#daysJsonBox"
  },

  // --- Compo corporelle ---
  body: {
    mw:"#morningWeight", fp:"#fatPct", mp:"#musclePct", bk:"#boneKg",
    avg7:"#avg7Weight", wkVar:"#wkVarPct",
    bmiUsed:"#bmiWeightUsed", bmiVal:"#bmiVal", bmiCat:"#bmiCat",
    trend: {
      spend:"#avg7SpendKcal", eat:"#avg7EatKcal", def:"#avg7DefKcal",
      proj:"#projWkKg", cmp:"#deltaRealVsTheo", qual:"#dataQuality7", note:"#trend7Note"
    }
  },

  // --- Viz calories (panneau pédagogique) ---
  flow: {
    card:"#calFlowCard",
    bars:"#barP,#barC,#barF",
    delta:"#flow_deltaKcal",
    txt:"#flow_targetKcal,#flow_spendKcal,#flow_pKcal,#flow_cKcal,#flow_fKcal,#flow_pG,#flow_cG,#flow_fG",
    cap:"#flow_capState,#flow_capG,#flow_cTheoG,#flow_shiftKcal,#flow_fBaseG,#flow_fExtraG"
  },

  // --- Diabète ---
  diab: {
    enabled:"#diabEnabled",
    menuItem:"#diabMenuItem",
    panel:"#diabPanelInRepas",
    quickStatus:"#diabQuickStatus",
    quick: {
      carb:"#diabQuickCarbG",
      net:"#diabQuickNetCarbG",
      portions:"#diabQuickPortions",
      last:"#diabQuickLastG",
      line:"#diabQuickLine",
      reco:"#diabQuickReco",
      recoText:"#diabQuickRecoText",
},
    blocksWrap:"#diabBlocksWrap",
    blocksHome:"#diabBlocksHome"
  },

  // --- Cloud sync ---
  cloud: {
    status:"#cloudStatus",
    email:"#cloudEmail",
    btnLogin:"#btnCloudLogin",
    btnLogout:"#btnCloudLogout",
    btnPull:"#btnCloudPull",
    btnPush:"#btnCloudPush",
    btnSync:"#btnCloudSync"
  },

  // --- Modal info montre ---
  modal: {
    trigger:"#watchProfileInfo",
    modal:"#watchInfoModal",
    body:"#watchInfoBody",
    close:"#watchInfoClose",
    ok:"#watchInfoOk",
    backdrop:"#watchInfoModal .modal__backdrop"
  },

  // --- Boutons ---
  actions: {
    calcSpend:"#calcSpendBtn"
  }
};

/* =========================
   1) Utils (ne touche pas au DOM sauf via $)
   ========================= */
const $ = (id) => document.getElementById(id);

const toNum = (v) => {
  const s = String(v ?? "").replace(",", ".").trim();
  const n = parseFloat(s);
  return Number.isFinite(n) ? n : 0;
};
const round = (v, d=1) => {
  const f = Math.pow(10, d);
  return Math.round((v + Number.EPSILON) * f) / f;
};
const clamp = (v, min, max) => Math.min(max, Math.max(min, v));

function escapeHtml(s){
  return String(s ?? "")
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"&quot;")
    .replaceAll("'","&#39;");
}

function isoToday() { return new Date().toISOString().slice(0,10); }
function getSelectedDate() {
  const v = $("dayDate")?.value;
  return v && v.length === 10 ? v : isoToday();
}
function refreshDaySelect(){ /* no-op compat */ }
function initPinnedTips(){
  // 1) Info-dots : délégation de clic → réutilise la modale "watchInfoModal"
  document.addEventListener("click", (e) => {
    const dot = e.target?.closest?.(".info-dot");
    if (!dot) return;
    e.preventDefault();
    const txt = dot.getAttribute("data-modaltext") || dot.getAttribute("data-help") || "";
    if (!txt) return;
    try { openWatchInfoModal(txt); } catch(err) { console.warn("info-dot modal failed", err); }
  });

  // 2) Assure l'existence de l'élément d'explication des repères glucidiques
  if (!$("carbGuardExplain")) {
    const anchor = $("dietNote") || $("carbCapGPerKg") || document.body;
    const div = document.createElement("div");
    div.id = "carbGuardExplain";
    div.className = "muted mt-02";
    div.textContent = "";
    // insertion la plus sûre : juste avant dietNote si possible
    if (anchor && anchor.parentNode) {
      if (anchor.id === "dietNote") anchor.parentNode.insertBefore(div, anchor);
      else anchor.parentNode.appendChild(div);
    }
  }

  // 3) Patch CSS injecté via structure JS "patch"
  const patch = {
    css: `
      /* PATCH v17.1 — ergonomie info-dots + zone explicative repères */
      .info-dot{ cursor:pointer; }
      #carbGuardExplain{ opacity:.92; }
    `,
    apply(){
      if (document.getElementById("patchStyle")) return;
      const st = document.createElement("style");
      st.id = "patchStyle";
      st.textContent = this.css;
      document.head.appendChild(st);
    }
  };
  patch.apply();
}

function mifflinStJeor(sex, weightKg, heightCm, ageY) {
  if (sex === "M") return 10*weightKg + 6.25*heightCm - 5*ageY + 5;
  return 10*weightKg + 6.25*heightCm - 5*ageY - 161;
}

/* =====================================================================
   2) CGU / Verrouillage
   UI piloté: #ackTerms, .tabBtn[data-tab], .menuItem[data-tab]
   ===================================================================== */
const TERMS_KEY = "termsAccepted_v1";

function isTermsAccepted(){
  try { return localStorage.getItem(TERMS_KEY) === "1"; }
  catch(e){ return false; }
}
function setTermsAccepted(ok){
  try { localStorage.setItem(TERMS_KEY, ok ? "1" : "0"); }
  catch(e){}
}
function setAppLocked(locked){
  document.documentElement.classList.toggle("app-locked", !!locked);
  document.querySelectorAll(".tabBtn, .menuItem").forEach(el => {
    const tab = el.getAttribute("data-tab");
    const allow = (tab === "welcome");
    el.classList.toggle("is-disabled", locked && !allow);
    el.setAttribute("aria-disabled", (locked && !allow) ? "true" : "false");
  });
}

/* =====================================================================
   X) MONTRE & MODES (indispensable)
   - WATCH_ESTIMATION_PROFILES
   - applyBrandPreset()
   - setPositioningCopy()
   - applyUseMode()
   ===================================================================== */
      const WATCH_ESTIMATION_PROFILES = {
        custom:{ label:"Personnalisé", defaultErrPct:20, defaultMode:"conservative", confidence:"variable", role:"aucune hypothèse", notes:"Aucune hypothèse implicite. L’erreur est définie par l’utilisateur." },
        apple:{ label:"Apple Watch", defaultErrPct:25, defaultMode:"conservative", confidence:"modérée", role:"profil statistique", notes:"Profil d’estimation initial. Forte variabilité selon l’activité." },
        garmin:{ label:"Garmin", defaultErrPct:20, defaultMode:"optimistic", confidence:"modérée", role:"profil statistique", notes:"Profil d’estimation initial. Variabilité importante selon contexte." },
        polar:{ label:"Polar", defaultErrPct:20, defaultMode:"optimistic", confidence:"modérée", role:"profil statistique", notes:"Profil d’estimation initial. L’énergie reste une estimation bruitée." },
        coros:{ label:"COROS", defaultErrPct:25, defaultMode:"optimistic", confidence:"limitée", role:"profil terrain", notes:"Peu de validations indépendantes sur l’énergie. Valeur prudente." },
        samsung:{ label:"Samsung", defaultErrPct:30, defaultMode:"conservative", confidence:"faible", role:"profil grand public", notes:"Valeur conservatrice par manque de données robustes." },
        suunto:{ label:"Suunto", defaultErrPct:25, defaultMode:"optimistic", confidence:"limitée", role:"profil terrain", notes:"Variabilité élevée selon l’activité." },
        huawei:{ label:"Huawei", defaultErrPct:30, defaultMode:"conservative", confidence:"faible", role:"profil grand public", notes:"Peu de données indépendantes sur l’estimation calorique." },
        amazfit:{ label:"Amazfit", defaultErrPct:30, defaultMode:"conservative", confidence:"faible", role:"profil grand public", notes:"Estimation calorique indicative uniquement." },
        fitbit:{ label:"Fitbit / Google", defaultErrPct:25, defaultMode:"conservative", confidence:"modérée", role:"profil statistique", notes:"Variabilité importante selon activité. Utile pour tendances." }
      };

      function applyBrandPreset(brandKey, force = false) {
        const p = WATCH_ESTIMATION_PROFILES[brandKey] || WATCH_ESTIMATION_PROFILES.custom;
        const infoEl = document.getElementById("watchProfileInfo");

        if (infoEl) {
          const lines = [
            `Profil : ${p.role || "repère initial"}`,
            `Niveau de confiance : ${p.confidence || "variable"}`,
            "",
            p.notes || "Aucune information complémentaire."
          ];
          infoEl.setAttribute("data-modaltext", lines.join("\n"));
        }

        if (force) {
          if ($("errPct")) $("errPct").value = p.defaultErrPct;
          if ($("errMode")) $("errMode").value = p.defaultMode;
        }
      }

      function setPositioningCopy(mode) {
        const el = $("positioningText");
        if (!el) return;

        if (mode === "sport") {
          el.textContent = "Mode sportif : vise un déficit tenable. Charge + déficit trop élevés = fatigue et performance en baisse.";
          return;
        }
        if (mode === "expert") {
          el.textContent = "Mode expert : la valeur du jour peut varier. Lis surtout la tendance sur 7 jours.";
          return;
        }
        el.textContent = "Mode simple : vise la régularité sur 7 jours. Affichage allégé, sans pression au quotidien.";
      }

      function applyUseMode(mode) {
        const m = (mode === "sport" || mode === "expert") ? mode : "simple";
        document.body.setAttribute("data-usemode", m);

        setPositioningCopy(m);

        const det = $("limitsDetails");
        if (det) det.open = (m === "expert");
}

/* =====================================================================
   3) Navigation / Tabs / Menu (desktop + mobile)
   UI piloté: #menuBtn, #menuPanel, .menuItem, .tabBtn, .tabSection
   ===================================================================== */
function closeMenu(){
  const panel = $("menuPanel");
  const btn = $("menuBtn");
  if (!panel || !btn) return;
  panel.classList.remove("is-open");
  btn.setAttribute("aria-expanded", "false");
}
function openMenu(){
  const panel = $("menuPanel");
  const btn = $("menuBtn");
  if (!panel || !btn) return;
  panel.classList.add("is-open");
  btn.setAttribute("aria-expanded", "true");
}
function toggleMenu(){
  const panel = $("menuPanel");
  if (!panel) return;
  panel.classList.contains("is-open") ? closeMenu() : openMenu();
}

function setActiveTab(tab){
  if (!isTermsAccepted() && tab !== "welcome"){
    alert("Lis et coche 'Conditions générales' pour déverrouiller l’application.");
    return;
  }

  const menuItems = document.querySelectorAll(".menuItem");
  const tabBtns   = document.querySelectorAll(".tabBtn");
  const sections  = document.querySelectorAll(".tabSection");

  menuItems.forEach(i => i.classList.toggle("is-active", i.dataset.tab === tab));
  tabBtns.forEach(b  => b.classList.toggle("is-active", b.dataset.tab === tab));
  sections.forEach(s => s.classList.toggle("is-active", s.dataset.tabsection === tab));

  // ✅ Monte / démonte le panneau Résultats selon l'onglet (goal + repas)
  mountResultsPanel(tab);

  try{ localStorage.setItem("secheapp.ui.activeTab", tab); }catch{}

  // ✅ Entrée onglet repas => forcer tableau + totaux + calcul
  if (tab === "repas") {
    const d = getSelectedDate();
    renderMealsTable(d);
    syncEatenFromMeals(d);
    compute(true);
  }

  // ✅ Entrée onglet objectif => recalcul (évite résultats obsolètes)
  if (tab === "goal") {
    compute(true);
  }

  try{ closeMenu(); }catch{}
}

function initTabs(){
  const saved = localStorage.getItem("secheapp.ui.activeTab") || "dash";
  setActiveTab(isTermsAccepted() ? saved : "welcome");

  // Menu items
  document.querySelectorAll(".menuItem").forEach(btn => {
    btn.addEventListener("click", () => {
      setActiveTab(btn.dataset.tab);
      closeMenu();
    });
  });

  // Hamburger
  $("menuBtn")?.addEventListener("click", (e) => {
    e.stopPropagation();
    toggleMenu();
  });

  // Click extérieur
  document.addEventListener("click", (e) => {
    const panel = $("menuPanel");
    const btn = $("menuBtn");
    if (!panel || !btn) return;
    if (!panel.classList.contains("is-open")) return;
    if (!panel.contains(e.target) && !btn.contains(e.target)) closeMenu();
  });

  // Escape
  document.addEventListener("keydown", (e) => {
    if (e.key === "Escape") closeMenu();
  });

  // Historique: suppr journée (délégation)
  document.addEventListener("click", (e) => {
    const btn = e.target.closest?.('button[data-action="del-day"]');
    if (!btn) return;
    e.preventDefault(); e.stopPropagation();
    const dateStr = btn.getAttribute("data-date");
    if (!dateStr) return;
    if (!confirm(`Supprimer la journée complète du ${dateStr} ?`)) return;

    if (typeof deleteDay === "function") deleteDay(dateStr);
    else { if ($("dayDate")) $("dayDate").value = dateStr; $("btnDeleteDay")?.click(); return; }

    renderDaysHistory();
    renderMealsTable(getSelectedDate());
    updateBodyCompUI(getSelectedDate());
    compute(true);
  });

  // Historique diabète: suppr données diab jour (délégation)
  document.addEventListener("click", (e) => {
    const btn = e.target.closest?.('button[data-action="diab-del-day"]');
    if (!btn) return;
    e.preventDefault(); e.stopPropagation();
    const dateStr = btn.getAttribute("data-date");
    if (!dateStr) return;
    if (!confirm(`Supprimer uniquement les données diabète du ${dateStr} ?`)) return;
    diab_deleteDiabDataForDay(dateStr);
  });
}

function mountResultsPanel(activeTab){
  const out = $("out");
  if (!out) return;

  const goalMount  = $("outMountGoal");
  const repasMount = $("outMountRepas");

  const shouldShow = (activeTab === "goal" || activeTab === "repas");
  out.classList.toggle("hidden", !shouldShow);

  if (!shouldShow) return;

  const target = (activeTab === "goal") ? goalMount : repasMount;
  if (!target) return;

  // Déplace le même node (pas de duplication => pas de conflit d'IDs)
  if (out.parentNode !== target) target.appendChild(out);
}


/* =====================================================================
   4) Presets / Régimes / Repères glucidiques / Plancher lipides
   UI piloté: #dietMode, #goalPct, #protPerKg, #fatPerKg,
              #carbGoal, #carbStep, #carbCapGPerKg, #ratioCP,
              #fatFloorGPerKg, #fatFloorExplain, #fatRangeHint,
              #carbAutoHint, #protRangeHint
   ===================================================================== */

/* ===== labels régime ===== */
function dietLabel(mode){
  if (!mode || mode === "none") return "—";
  if (mode === "custom") return "Personnalisé";
  if (typeof DIET_PRESETS !== "undefined" && DIET_PRESETS[mode]?.label) return DIET_PRESETS[mode].label;
  return mode;
}

const DIET_PRESETS = {
  cut_standard:   { label:"Standard (sportif)",     goalPct: 85,  protPerKg: 1.9, fatPerKg: 0.9 },
  cut_aggressive: { label:"Agressif (court terme)", goalPct: 75,  protPerKg: 2.2, fatPerKg: 0.8 },
  recomp:         { label:"Recomposition (léger déficit)", goalPct: 92,  protPerKg: 1.8, fatPerKg: 0.9 },
  maintain:       { label:"Maintien / équilibre",   goalPct: 100, protPerKg: 1.6, fatPerKg: 1.0 },
  endurance:      { label:"Performance endurance",  goalPct: 95,  protPerKg: 1.7, fatPerKg: 0.9 }
};

function setDietNote(modeKey){
  const el = $("dietNote");
  if (!el) return;

  if (!modeKey) { el.textContent = "Presets = valeurs de départ. Si tu modifies objectif/prot/lip, l’app bascule en “Personnalisé”."; return; }
  if (modeKey === "none") { el.textContent = "—"; return; }
  if (modeKey === "custom") { el.textContent = "Mode Personnalisé : tu ajustes librement objectif / protéines / lipides."; return; }

  const p = DIET_PRESETS[modeKey];
  if (!p) { el.textContent = "Presets = valeurs de départ. Si tu modifies objectif/prot/lip, l’app bascule en “Personnalisé”."; return; }
  el.textContent = `Preset “${p.label}” : ${p.goalPct}% · prot ${p.protPerKg} g/kg · lip ${p.fatPerKg} g/kg. (Modifier objectif/prot/lip ⇒ “Personnalisé”.)`;
}

function setDietNoneUI(){
  if ($("goalPct")) $("goalPct").value = "0";
  if ($("protPerKg")) $("protPerKg").value = "0";
  if ($("fatPerKg")) $("fatPerKg").value = "0";
  if ($("dietNote")) $("dietNote").textContent = "—";
  if ($("carbAutoHint")) $("carbAutoHint").textContent = "Plafond glucidique : —";
  if ($("protRangeHint")) $("protRangeHint").textContent = "Plage protéines : —";
  if ($("fatFloorGPerKg")) $("fatFloorGPerKg").value = 0;
  if ($("fatFloorExplain")) $("fatFloorExplain").textContent = "Plages lipides : —";
  if ($("fatRangeHint")) $("fatRangeHint").textContent = "Plage lipides : —";
  if ($("carbGoal")) $("carbGoal").value = "none";
  if ($("carbCapGPerKg")) $("carbCapGPerKg").value = 0;
  if ($("ratioCP")) $("ratioCP").value = 0;
}

/* ===== Repères glucidiques ===== */
const CARB_GOALS = {
  strict:   { label: "Sèche stricte (2–3 g/kg/j)",   range:[2,3],   steps:[2.0,2.2,2.5,3.0] },
  sport:    { label: "Sèche sportive (3–4 g/kg/j)",  range:[3,4],   steps:[3.0,3.2,3.5,4.0] },
  recomp:   { label: "Recomposition (4–5 g/kg/j)",   range:[4,5],   steps:[4.0,4.2,4.5,5.0] },
  maintain: { label: "Maintien actif (4–6 g/kg/j)",  range:[4,6],   steps:[4.0,4.5,5.0,5.5,6.0] },
  volume:   { label: "Endurance / volume (6–8 g/kg/j)", range:[6,8], steps:[6.0,6.5,7.0,7.5,8.0] },
  carbload: { label: "Carb-loading (8–12 g/kg/j)",   range:[8,12],  steps:[8,9,10,11,12] }
};

const LOW_CARB_GOALS = {
  moderate: { label: "Low-carb modéré (1,5–2,0 g/kg/j)", range:[1.5,2.0], steps:[1.5,1.7,2.0] },
  strict:   { label: "Low-carb strict (0,5–1,0 g/kg/j)", range:[0.5,1.0], steps:[0.5,0.7,1.0] }
};

const PROT_RANGES = {
  cut_standard:   { min: 1.8, max: 2.0, def: 1.9 },
  cut_aggressive: { min: 2.0, max: 2.3, def: 2.2 },
  recomp:         { min: 1.6, max: 1.8, def: 1.7 },
  maintain:       { min: 1.4, max: 1.6, def: 1.5 },
  endurance:      { min: 1.6, max: 1.8, def: 1.7 },
};

const FAT_FLOOR_RANGES_BY_DIET = {
  cut_aggressive: { min: 0.8, max: 1.0 },
  cut_standard:   { min: 0.9, max: 1.1 },
  recomp:         { min: 0.9, max: 1.1 },
  maintain:       { min: 0.9, max: 1.2 },
  endurance:      { min: 0.8, max: 1.0 },
  custom:         { min: 0.0, max: 5.0 }
};

const FAT_FLOORS = {
  strict:   { min: 0.8, note: "Plancher 0,8 g/kg (socle hormonal + vitamines)." },
  sport:    { min: 0.8, note: "Plancher 0,8 g/kg (souvent 0,8–0,9 selon charge)." },
  recomp:   { min: 0.9, note: "Plancher 0,9 g/kg (stabilité & durée)." },
  maintain: { min: 0.9, note: "Plancher 0,9 g/kg (souvent 0,9–1,0 en maintien actif)." },
  volume:   { min: 1.0, note: "Plancher 1,0 g/kg (volume/endurance : récupération + énergie)." },
  carbload: { min: 0.6, note: "Carb-loading : 0,6–0,7 g/kg possible 48–72 h (exception transitoire)." }
};

function fatFloorForGoal(goalKey){
  return FAT_FLOORS[goalKey] || { min: 0, note: "-" };
}

function setProtRangeUI(mode, clampValue){
  const el = $("protPerKg");
  const hint = $("protRangeHint");
  if (!el) return;

  const r = PROT_RANGES[mode];

  if (!r || mode === "custom"){
    el.min = "0"; el.max = "5"; el.step = "0.1";
    if (hint) hint.textContent = "Plage protéines : libre";
    return;
  }

  el.min = String(r.min);
  el.max = String(r.max);
  el.step = "0.1";

  if (clampValue){
    el.value = clamp(toNum(el.value), r.min, r.max).toFixed(1);
  }
  if (hint) hint.textContent = `Plage protéines : ${r.min.toFixed(1)} – ${r.max.toFixed(1)} g/kg`;
}

function lockMacroControls(isCustom){
  const lock = !isCustom;
  ["goalPct"].forEach(id => { const el = $(id); if (el) el.disabled = lock; });
  if ($("protPerKg")) $("protPerKg").disabled = false;
  if ($("fatPerKg")) $("fatPerKg").disabled = lock;
  if ($("carbAutoHint")) $("carbAutoHint").disabled = true;

  const fatBox = $("fatPerKgBox");
  if (fatBox) fatBox.classList.remove("hidden");
  const carbAutoBox = $("carbAutoBox");
  if (carbAutoBox) carbAutoBox.classList.remove("hidden");
}

function forceCustomIfPresetEdited(){
  const dm = $("dietMode");
  if (!dm) return;
  if (dm.value === "custom") return;
  dm.value = "custom";
  setDietNote("none");
  lockMacroControls(true);
  setProtRangeUI("custom", false);

  if ($("carbGoal")) {
    updateCarbGoalOptions(true);
    updateCarbSteps();
    lockCarbControls();
    syncCarbGuardsFromUI();
    updateFatFloorUI();
  }
}

function setRatioToMatchCap(){
  const capEl = $("carbCapGPerKg");
  const protEl = $("protPerKg");
  const ratioEl = $("ratioCP");
  if (!capEl || !protEl || !ratioEl) return;

  const cap = toNum(capEl.value);
  const prot = toNum(protEl.value);
  if (!(cap > 0) || !(prot > 0)) return;

  ratioEl.value = round(cap / prot, 2);
}

if (typeof window.lockCarbControls !== "function"){
  window.lockCarbControls = function(locked){
    ["carbGoal","carbStep","carbCapGPerKg"].forEach(id => { const el = $(id); if (el) el.disabled = !!locked; });
  };
}
if (typeof window.syncCarbGuardsFromUI !== "function"){
  window.syncCarbGuardsFromUI = function(){
    const goal = $("carbGoal")?.value || "off";
    updateCarbSteps(goal, false);
    updateCarbGuardExplain();
  };
}

function resetCarbGoalDerivedUI(){
  if ($("carbAutoHint")) $("carbAutoHint").value = "Glucides auto : 0 g/j (aucun régime)";
  if ($("carbCapGPerKg")) $("carbCapGPerKg").value = "0";
  if ($("carbStep")) $("carbStep").selectedIndex = 0;
if ($("fatFloorGPerKg")) $("fatFloorGPerKg").value = "0";
  if ($("fatFloorExplain")) $("fatFloorExplain").textContent = "Plages lipides : —";
}

function updateFatFloorUI(){
  const goalKey = ($("carbGoal")?.value) || "off";
  const floor = fatFloorForGoal(goalKey);
  const floorMin = floor.min ? toNum(floor.min) : 0;

  const mode = $("dietMode")?.value || "custom";
  const el = $("fatFloorGPerKg");
  const explain = $("fatFloorExplain");
  const rangeHint = $("fatRangeHint");
  if (!el) return;

  const dr = FAT_FLOOR_RANGES_BY_DIET[mode] || FAT_FLOOR_RANGES_BY_DIET.custom;
  let minAllowed = toNum(dr.min);
  let maxAllowed = toNum(dr.max);

  if (floorMin > 0) minAllowed = Math.max(minAllowed, floorMin);
  if (goalKey === "carbload") minAllowed = Math.max(0.6, minAllowed);
  if (goalKey === "off") { minAllowed = 0; maxAllowed = 5; }

  let fatFloorIncompatible = false;
  if (minAllowed > maxAllowed) { fatFloorIncompatible = true; maxAllowed = minAllowed; }

  el.min = String(minAllowed);
  el.max = String(maxAllowed);
  el.step = "0.1";

  if (rangeHint){
    rangeHint.textContent = "Plage lipides : " + round(minAllowed,2) + " – " + round(maxAllowed,2) + " g/kg";
  }

  let chosen = toNum(el.value);
  if (!isFinite(chosen) || chosen <= 0) chosen = minAllowed;
  chosen = Math.max(minAllowed, Math.min(maxAllowed, chosen));

  if ($("fatFloorGPerKg")) $("fatFloorGPerKg").value = round(chosen, 2);
  el.value = round(chosen, 2);

  if (explain){
    const base = floor.note || "-";
    if (floorMin > 0 && chosen > floorMin + 1e-9){
      explain.textContent = base + " (plancher " + round(floorMin,2) + " g/kg, choisi: " + round(chosen,2) + " g/kg)";
    } else {
      explain.textContent = base + (fatFloorIncompatible ? " ⚠️ Objectif incompatible avec le palier régime." : "");
    }
  }
}

function updateCarbGuardExplain(){
  const goalKey = ($("carbGoal")?.value) || "off";
  const step = ($("carbStep")?.value) || "0";
  const cap = toNum($("carbCapGPerKg")?.value);
  const ratio = toNum($("ratioCP")?.value);

  const box = $("carbGuardExplain");
  if (!box) return;

  if (goalKey === "off"){
    box.textContent = "";
    updateFatFloorUI();
    return;
  }

  // (ton CARB_EXPLAIN est plus haut dans ton fichier : garde-le si tu veux)
  const meta = (typeof CARB_EXPLAIN !== "undefined" && CARB_EXPLAIN[goalKey])
    ? CARB_EXPLAIN[goalKey]
    : { label: goalKey, range: "-", protects: "-", examples: "-" };

  const stepTxt = (toNum(step) > 0) ? ` | palier : ${step} g/kg/j` : "";
  const capTxt  = (cap > 0) ? ` | plafond : ${cap} g/kg/j` : "";
  const ratioTxt= (ratio > 0) ? ` | ratio max C:P = ${round(ratio,2)}` : "";

 // box.textContent = `${meta.label} (${meta.range})${stepTxt}${capTxt}${ratioTxt} — protège : ${meta.protects}. Exemples : ${meta.examples}.`;
  updateFatFloorUI();
}

/* --- Listes objectifs glucides : compatibilité régime -> objectifs --- */
const DIET_CARB_COMPAT = {
  cut_standard:   { strict:"warn", sport:"ok",  recomp:"ok",  maintain:"warn", volume:"no",   carbload:"no" },
  cut_aggressive: { strict:"ok",   sport:"warn",recomp:"no",  maintain:"no",   volume:"no",   carbload:"no" },
  recomp:         { strict:"warn", sport:"ok",  recomp:"ok",  maintain:"warn", volume:"no",   carbload:"no" },
  maintain:       { strict:"no",   sport:"warn",recomp:"ok",  maintain:"ok",   volume:"warn", carbload:"no" },
  endurance:      { strict:"no",   sport:"warn",recomp:"warn",maintain:"ok",   volume:"ok",   carbload:"warn" },
  custom:         { strict:"ok",   sport:"ok",  recomp:"ok",  maintain:"ok",   volume:"ok",   carbload:"ok" }
};

const CARB_GOAL_DEFAULT_BY_DIET = {
  cut_standard: "sport",
  cut_aggressive: "strict",
  recomp: "sport",
  maintain: "maintain",
  endurance: "volume",
  custom: "sport"
};

function fmtCompatTag(code){
  if (code === "ok") return "✅ compatible";
  if (code === "warn") return "⚠️ possible (conditions)";
  return "❌ incohérent";
}
function setSelectOptions(sel, options, selectedValue){
  sel.innerHTML = "";
  options.forEach(optData => {
    const opt = document.createElement("option");
    opt.value = optData.value;
    opt.textContent = optData.label;
    if (optData.disabled) opt.disabled = true;
    if (optData.value === selectedValue) opt.selected = true;
    sel.appendChild(opt);
  });
}
function getDietCompatMap(dietMode){
  return DIET_CARB_COMPAT[dietMode] || DIET_CARB_COMPAT.custom;
}
function getCarbGoal(){ return $("carbGoal")?.value || "off"; }

function updateCarbGoalOptions(keepValue=true, forceNone=false){
  const dietMode = $("dietMode").value;
  const compat = getDietCompatMap(dietMode);
  const current = keepValue ? getCarbGoal() : null;

  const options = [
    { value: "none", label: "— Choisir un objectif —", disabled: false },
    ...Object.entries(CARB_GOALS).map(([key, g]) => {
      const c = compat[key] || "no";
      return {
        value: key,
        label: `${g.label} — ${fmtCompatTag(c)}`,
        disabled: (dietMode !== "custom" && c === "no")
      };
    })
  ];

  const sel = $("carbGoal");
  let chosen;

  if (forceNone) chosen = "none";
  else {
    const fallback = CARB_GOAL_DEFAULT_BY_DIET[dietMode] || "sport";
    const currentOk = current && options.find(o => o.value === current && !o.disabled);
    chosen = (currentOk ? current : null) || fallback;
  }
  setSelectOptions(sel, options, chosen);
}

function updateCarbSteps() {
  const goal = $("carbGoal").value;
  const mode = $("dietMode")?.value || "none";
  if (mode === "none" || goal === "none"){ resetCarbGoalDerivedUI(); return; }

  const stepSel = $("carbStep");
  const capInp = $("carbCapGPerKg");
  const ratioInp = $("ratioCP");
  const w = Math.max(0, toNum($("weight").value));

  const RANGES = {
    strict:   { min: 2.0,  max: 3.0,  recRatio: 1.00, label: "Sèche stricte" },
    sport:    { min: 3.0,  max: 4.0,  recRatio: 1.10, label: "Sèche sportive" },
    recomp:   { min: 4.0,  max: 5.0,  recRatio: 1.25, label: "Recomposition" },
    maintain: { min: 4.0,  max: 6.0,  recRatio: 1.50, label: "Maintien actif" },
    endurance:{ min: 6.0,  max: 8.0,  recRatio: 1.80, label: "Endurance / volume" },
    carbload: { min: 8.0,  max: 12.0, recRatio: 2.50, label: "Carb-loading" }
  };
  const r = RANGES[goal] || RANGES.sport;

  stepSel.innerHTML = "";
  const steps = [];
  for (let v = r.min; v <= r.max + 1e-9; v = Math.round((v + 0.1) * 10) / 10) steps.push(v);
  steps.forEach(v => {
    const opt = document.createElement("option");
    opt.value = String(v);
    opt.textContent = v.toFixed(1) + " g/kg/j";
    stepSel.appendChild(opt);
  });

  capInp.step = "0.1";
  capInp.min  = String(r.min);
  capInp.max  = String(r.max);

  const cur = toNum(capInp.value);
  const next = (cur > 0 && cur >= r.min - 1e-9 && cur <= r.max + 1e-9) ? cur : r.min;
  capInp.value = next.toFixed(1);

  stepSel.value = capInp.value;

  // ratioCP: ne pas écraser en mode régime (repères OFF). La priorité est gérée par applyRatioPriority().

  const capG = toNum(capInp.value);
  const maxCarbsG = (w > 0 && capG > 0) ? Math.round(capG * w) : 0;

  const __cge = $("carbGuardExplain");
  if (__cge) __cge.textContent =
    `${r.label} : plafond ${r.min.toFixed(1)}–${r.max.toFixed(1)} g/kg/j. ` +
    `Plafond actuel = ${capG.toFixed(1)} → max ≈ ${maxCarbsG} g/j (pour ${Math.round(w)} kg). ` +
    `Ratio max C/P conseillé ≈ ${toNum(ratioInp.value).toFixed(2)}.`;

  const autoHint = $("carbAutoHint");
  if (autoHint){
    autoHint.value = `Plafond glucidique : ${capG.toFixed(1)} g/kg/j (≈ ${maxCarbsG} g/j)`;
  }
}

function initCarbGuardsUI(){
  try {
    updateCarbGoalOptions(true, false);
    updateCarbSteps();
    lockCarbControls?.();
    syncCarbGuardsFromUI?.();
    updateCarbGuardExplain?.();
    updateFatFloorUI?.();
    try{ applyRatioPriority('initCarbGuardsUI'); }catch(e){}
  } catch(e){
    console.error("initCarbGuardsUI failed:", e);
  }
}

/* --- low-carb UI --- */
function setLowCarbRangeUI(level, clampValue){
  const el = $("lowCarbStep");
  const help = $("lowCarbHelp");
  if (!el) return;

  const cfg = LOW_CARB_GOALS[level] || LOW_CARB_GOALS.moderate;
  const a = toNum(cfg.range?.[0]);
  const b = toNum(cfg.range?.[1]);

  if (!(a >= 0) || !(b > a)){
    el.min = "0"; el.max = "5"; el.step = "0.1";
    if (help) help.textContent = "";
    return;
  }

  el.min = String(a);
  el.max = String(b);
  el.step = "0.1";

  if (clampValue){
    const v = clamp(toNum(el.value), a, b);
    el.value = (Math.round(v * 10) / 10).toFixed(1);
  }

  if (help) help.textContent =
    `Fourchette : ${a.toFixed(1).replace(".",",")}–${b.toFixed(1).replace(".",",")} g/kg/j`;
}

function populateLowCarbSteps(){
  const levelSel = $("lowCarbLevel");
  const stepInp  = $("lowCarbStep");
  if (!levelSel || !stepInp) return;

  const level = levelSel.value || "moderate";
  const cfg = LOW_CARB_GOALS[level] || LOW_CARB_GOALS.moderate;
  const a = toNum(cfg.range?.[0]);
  const b = toNum(cfg.range?.[1]);

  // (1) Attributs du <input type="number"> : flèches verticales natives + pas 0,1
  setLowCarbRangeUI(level, false);

  // (2) Valeur courante : clamp strict dans la fourchette
  let v = toNum(stepInp.value);
  if (!isFinite(v)) v = a;
  v = clamp(v, a, b);

  // (3) Normalisation à 1 décimale (évite 1.7000000002)
  stepInp.value = (Math.round(v * 10) / 10).toFixed(1);
}

function syncCarbModeUI(){
  const carbGuard = !!$("carbGuardEnabled")?.checked;
  const lowCarb = !!$("lowCarbEnabled")?.checked;

  // Low-carb et repères sont exclusifs : si low-carb ON, on force repères OFF
  if (lowCarb && carbGuard && $("carbGuardEnabled")) $("carbGuardEnabled").checked = false;

  const carbGuard2 = !!$("carbGuardEnabled")?.checked;
  const lowCarb2 = !!$("lowCarbEnabled")?.checked;

  // ✅ mémoire interne : dernier objectif sélectionné quand les repères étaient ON
  // (pour pouvoir le restaurer si l'utilisateur réactive les repères)
  if (typeof window.__lastCarbGoalKey === "undefined") window.__lastCarbGoalKey = "";

  const goalEl = $("carbGoal");

  // Si on vient de désactiver les repères : on repasse en "-choisir un objectif-"
  // mais on conserve l'ancien choix en mémoire interne.
  if (!carbGuard2 && !lowCarb2 && goalEl){
    const prev = String(goalEl.value || "");
    if (prev) window.__lastCarbGoalKey = prev;
    goalEl.value = ""; // -> "-choisir un objectif-"
  }

  // Si on vient d'activer les repères : on peut restaurer le dernier objectif connu
  // uniquement si l'utilisateur n'a rien choisi (value="").
  if (carbGuard2 && !lowCarb2 && goalEl){
    const cur = String(goalEl.value || "");
    if (!cur && window.__lastCarbGoalKey){
      // restaure seulement si l'option existe encore
      const opt = goalEl.querySelector(`option[value="${CSS.escape(window.__lastCarbGoalKey)}"]`);
      if (opt) goalEl.value = window.__lastCarbGoalKey;
    }
  }

  if ($("carbGuardEnabled")) $("carbGuardEnabled").disabled = false;

  const lowBox = $("lowCarbBox");
  if (lowBox) lowBox.style.display = lowCarb2 ? "" : "none";

  const guardBox = $("carbGuardBox");
  if (guardBox) guardBox.style.display = (carbGuard2 && !lowCarb2) ? "" : "none";

  // Verrouillage des contrôles "repères" quand OFF ou en low-carb
  const lock = (!carbGuard2) || lowCarb2;
  ["carbGoal","carbStep","carbCapGPerKg"].forEach(id=>{
    const el = $(id);
    if (el) el.disabled = lock;
  });

  // Nettoyage du texte d'aide en mode repères OFF (et pas low-carb)
  if (!carbGuard2 && !lowCarb2) {
    if ($("carbGoalHelp")) $("carbGoalHelp").textContent = "";
  }

  // Mise à jour des pas / ratio si repères ON (après une éventuelle restauration d'objectif)
  if (carbGuard2 && !lowCarb2){
    updateCarbSteps?.();
    setRatioToMatchCap?.();
    syncCarbGuardsFromUI?.();
  }

  if (lowCarb2) populateLowCarbSteps();
}

function makeDietBadge(dietMode, goalPct) {
  const label = dietLabel(dietMode);
  const pct = Number.isFinite(goalPct) ? Math.round(goalPct) : "-";
  return `<span class="pill"><b>${escapeHtml(label)}</b> ${pct}%</span>`;
}

function applyDietPreset(mode) {
  if (mode === "custom") return;
  const p = DIET_PRESETS[mode];
  if (!p) return;

  $("goalPct").value   = p.goalPct;
  $("protPerKg").value = p.protPerKg;
  setProtRangeUI(mode, false);
  $("fatPerKg").value  = p.fatPerKg;

  updateCarbGoalOptions(true, true); // 🔒 pas de présélection
  updateCarbSteps();
  setRatioToMatchCap();
  syncCarbGuardsFromUI();
}

/* =====================================================================
   5) Profils / Storage (profil actif, settings, days)
   UI piloté: #profileSelect, #btnCreateProfile, #btnDeleteProfile
   ===================================================================== */

const PROFILES_KEY = "secheapp.profiles.v1";
const ACTIVE_PROFILE_KEY = "secheapp.activeProfile.v1";

      function slugProfile(name) {
        return String(name ?? "")
          .trim()
          .toLowerCase()
          .replace(/\s+/g, "-")
          .replace(/[^a-z0-9\-_]/g, "")
          .slice(0, 40);
      }
      function loadProfiles() {
        try { return JSON.parse(localStorage.getItem(PROFILES_KEY) || "[]"); }
        catch { return []; }
      }
      function saveProfiles(list) { localStorage.setItem(PROFILES_KEY, JSON.stringify(list)); }
      function getActiveProfile() { return localStorage.getItem(ACTIVE_PROFILE_KEY) || ""; }
      function setActiveProfile(id) { localStorage.setItem(ACTIVE_PROFILE_KEY, id); }

      function ensureDefaultProfile() {
        let profiles = loadProfiles();
        if (profiles.length === 0) {
          profiles = [{ id: "default", label: "default" }];
          saveProfiles(profiles);
          setActiveProfile("default");
        }
        if (!getActiveProfile()) setActiveProfile(profiles[0].id);
      }

      function refreshProfileSelect() {
        const sel = $("profileSelect");
        if (!sel) return;
        const profiles = loadProfiles();
        const active = getActiveProfile();
        sel.innerHTML = "";
        for (const p of profiles) {
          const opt = document.createElement("option");
          opt.value = p.id;
          opt.textContent = p.label;
          if (p.id === active) opt.selected = true;
          sel.appendChild(opt);
        }
      }

      function daysKeyFor(profileId) { return `secheapp.${profileId}.days.v6`; }
      function settingsKeyFor(profileId) { return `secheapp.${profileId}.settings.v2`; }
      function DAYS_KEY() { return daysKeyFor(getActiveProfile() || "default"); }
      function SETTINGS_KEY() { return settingsKeyFor(getActiveProfile() || "default"); }
      function createOrActivateProfile(label) {
        const cleanLabel = String(label ?? "").trim();
        if (!cleanLabel) return;
        const id = slugProfile(cleanLabel) || "profile";
        let profiles = loadProfiles();
        if (!profiles.find(p => p.id === id)) {
          profiles.push({ id, label: cleanLabel });
          saveProfiles(profiles);
        }
        setActiveProfile(id);
        refreshProfileSelect();
        loadProfileSettings();
        lockMacroControls($("dietMode").value === "custom");
        updateCarbGuardExplain();
        updateFatFloorUI();
        refreshDaySelect();
        renderDaysHistory();
        renderMealsTable(getSelectedDate());
        updateBodyCompUI(getSelectedDate());
        compute(true);
      }

      function deleteActiveProfile() {
        const active = getActiveProfile();
        if (active === "default") { alert("Le profil 'default' ne peut pas être supprimé."); return; }
        localStorage.removeItem(daysKeyFor(active));
        localStorage.removeItem(settingsKeyFor(active));
        let profiles = loadProfiles().filter(p => p.id !== active);
        saveProfiles(profiles);
        const next = profiles[0]?.id || "default";
        setActiveProfile(next);
        refreshProfileSelect();
        loadProfileSettings();
        lockMacroControls($("dietMode").value === "custom");
        updateCarbGuardExplain();
        updateFatFloorUI();
        refreshDaySelect();
        renderDaysHistory();
        renderMealsTable(getSelectedDate());
        updateBodyCompUI(getSelectedDate());
        compute(true);
      }

      function saveProfileSettings() {
          const payload = {
          sex: $("sex").value,
          age: toNum($("age").value),
          height: toNum($("height").value),
          weight: toNum($("weight").value),

          watchBrand: $("watchBrand").value,
          montre: toNum($("montre").value),
          errPct: toNum($("errPct")?.value),
          errMode: $("errMode")?.value,

          dietMode: $("dietMode")?.value,
          goalPct: toNum($("goalPct")?.value),

          protPerKg: toNum($("protPerKg")?.value),
          fatPerKg: toNum($("fatPerKg")?.value),

          carbGoal: $("carbGoal")?.value || "sport",
          carbCapGPerKg: toNum($("carbCapGPerKg")?.value),
          ratioCP: toNum($("ratioCP")?.value),

          useMode: $("useMode")?.value || "simple",


          diabEnabled: !!$("diabEnabled")?.checked,
          updatedAt: new Date().toISOString()
        };
        localStorage.setItem(SETTINGS_KEY(), JSON.stringify(payload));
      }

      function loadProfileSettings() {
        let payload = null;
        try { payload = JSON.parse(localStorage.getItem(SETTINGS_KEY()) || "null"); } catch {}
        if (!payload) return;

        const has = (k) => Object.prototype.hasOwnProperty.call(payload, k);

        if (has("sex") && payload.sex) $("sex").value = payload.sex;
        if (has("age")) $("age").value = payload.age;
        if (has("height")) $("height").value = payload.height;
        if (has("weight")) $("weight").value = payload.weight;

        if (has("watchBrand") && payload.watchBrand) $("watchBrand").value = payload.watchBrand;
        applyBrandPreset($("watchBrand").value, false);

        if (has("montre")) $("montre").value = payload.montre;
        if (has("errPct") && $("errPct")) $("errPct").value = payload.errPct;
        if (has("errMode") && payload.errMode && $("errMode")) $("errMode").value = payload.errMode;

        if (has("dietMode") && payload.dietMode && $("dietMode")) $("dietMode").value = payload.dietMode;

        if (has("useMode") && $("useMode")) {
          const v = payload.useMode;
          $("useMode").value = (v === "sport" || v === "expert") ? v : "simple";
        }

        if (has("goalPct") && $("goalPct")) $("goalPct").value = payload.goalPct;
        if (has("protPerKg") && $("protPerKg")) $("protPerKg").value = payload.protPerKg;
        if (has("fatPerKg") && $("fatPerKg")) $("fatPerKg").value = payload.fatPerKg;

        if (has("carbGoal") && $("carbGoal")) $("carbGoal").value = payload.carbGoal || $("carbGoal").value;
        if (has("carbCapGPerKg") && $("carbCapGPerKg")) $("carbCapGPerKg").value = payload.carbCapGPerKg ?? 0;
        if (has("ratioCP") && $("ratioCP")) $("ratioCP").value = payload.ratioCP ?? 0;
        if ($("carbGoal")) { updateCarbGoalOptions(false, true); updateCarbSteps(); lockCarbControls(); syncCarbGuardsFromUI(); }
        if ($("dietMode")) setDietNote($("dietMode").value, false);
        if (has("diabEnabled") && $("diabEnabled")) $("diabEnabled").checked = !!payload.diabEnabled;
        applyDiabMode($("diabEnabled")?.checked);
        applyUseMode($("useMode")?.value || "simple");
// ✅ Rejouer les UI dérivées du régime au chargement (sinon protRangeHint reste sur "—")
try{
  const mode = $("dietMode")?.value || "none";
  if (mode === "none" || mode === "") {
    // Important : ne pas appeler setDietNoneUI() ici si tu veux garder les valeurs restaurées.
    // On met juste le hint cohérent.
    if ($("protRangeHint")) $("protRangeHint").textContent = "Plage protéines : —";
  } else {
    setProtRangeUI(mode, false); // clampValue=false : on respecte protPerKg restauré
  }
}catch(e){}

      }

function refreshDietDerivedUI(){
  const mode = $("dietMode")?.value || "none";
  if (!mode || mode === "none"){
    if ($("protRangeHint")) $("protRangeHint").textContent = "Plage protéines : —";
    return;
  }
  setProtRangeUI(mode, false);
  // Optionnel : ici tu peux aussi recaler d’autres hints si besoin
}


      function loadDays() {
        try { return JSON.parse(localStorage.getItem(DAYS_KEY()) || "[]"); }
        catch { return []; }
      }

      function saveDays(days) { localStorage.setItem(DAYS_KEY(), JSON.stringify(days)); }
      function getDay(dateStr) { return loadDays().find(d => d.date === dateStr) || null; }

      function upsertDay(dayObj) {
        const days = loadDays();
        const idx = days.findIndex(d => d.date === dayObj.date);
        if (idx >= 0) days[idx] = dayObj; else days.push(dayObj);
        saveDays(days);
        renderDaysHistory();
        refreshDaySelect();
      }

      function deleteDay(dateStr) {
        let days = loadDays();
        days = days.filter(d => d.date !== dateStr);
        saveDays(days);
        renderDaysHistory();
        refreshDaySelect();
      }

      function deleteAllDays() {
        saveDays([]);          // vide l’historique
        renderDaysHistory();
        refreshDaySelect();
      } 

      function exportDays() {
        const payload = {
          version: 6,
          exportedAt: new Date().toISOString(),
          profile: getActiveProfile(),
          days: loadDays()
        };
        $("daysJsonBox").value = JSON.stringify(payload, null, 2);
      }

      function importDays() {
        const text = $("daysJsonBox").value.trim();
        if (!text) return;
        let payload;
        try { payload = JSON.parse(text); } catch { alert("JSON invalide"); return; }
        if (!payload || !Array.isArray(payload.days)) { alert("Format attendu: {days:[...]}."); return; }
        const existing = loadDays();
        const map = new Map(existing.map(d => [d.date, d]));
        for (const d of payload.days) {
          if (!d.date) continue;
          map.set(d.date, d);
        }
        saveDays(Array.from(map.values()));
        renderDaysHistory();
        refreshDaySelect();
      }

      function clearDays() {
        localStorage.removeItem(DAYS_KEY());
        renderDaysHistory();
        refreshDaySelect();
      }

/* =====================================================================
   6) Repas (CRUD + rendu)
   UI piloté: #mealsTableWrap, inputs meal*, #btnAddMeal, #btnClearMeals
   ===================================================================== */
      function normalizeMeal(m) {
        return {
          id: m.id || (crypto.randomUUID?.() ?? (`m_${Date.now()}_${Math.random().toString(16).slice(2)}`)),
          name: String(m.name ?? "").trim(),
          k: Math.max(0, toNum(m.k)),
          p: Math.max(0, toNum(m.p)),
          c: Math.max(0, toNum(m.c)),
          f: Math.max(0, toNum(m.f)),
          createdAt: m.createdAt || new Date().toISOString()
        };
      }

      function getMealsForDay(dateStr) {
        const d = getDay(dateStr);
        return Array.isArray(d?.meals) ? d.meals.map(normalizeMeal) : [];
      }

      function setMealsForDay(dateStr, meals) {
        const existing = getDay(dateStr) || { date: dateStr };
        const dayObj = { ...existing, date: dateStr, meals: meals.map(normalizeMeal), updatedAt: new Date().toISOString() };
        upsertDay(dayObj);
      }

      function mealsTotals(meals) {
        return meals.reduce((acc, m) => {
          acc.k += toNum(m.k); acc.p += toNum(m.p); acc.c += toNum(m.c); acc.f += toNum(m.f);
          return acc;
        }, {k:0,p:0,c:0,f:0});
      }

      function syncEatenFromMeals(dateStr) {
        const meals = getMealsForDay(dateStr);
        const t = mealsTotals(meals);
        if ($("eatenKcal")) $("eatenKcal").value = round(t.k, 0);
        if ($("eatenP")) $("eatenP").value = round(t.p, 1);
        if ($("eatenC")) $("eatenC").value = round(t.c, 1);
        if ($("eatenF")) $("eatenF").value = round(t.f, 1);
        return t;
      }

      function renderMealsTable(dateStr) {
        const wrap = $("mealsTableWrap");
        if (!wrap) return;

        const meals = getMealsForDay(dateStr).sort((a,b) => (a.createdAt||"").localeCompare(b.createdAt||""));

        if (meals.length === 0) {

  wrap.innerHTML = `
    <div class="meals-wrap">
       <table class="wide-table">
        <thead>
          <tr>
            <th class="text-left">Repas</th>
            <th>kcal</th>
            <th>P</th>
            <th>G</th>
            <th>L</th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td colspan="6" class="muted">Aucun repas ajouté pour l’instant.</td>
          </tr>
        </tbody>
      </table>
    </div>
  `;
  syncEatenFromMeals(dateStr);
  return;
}


        wrap.innerHTML = `
          <div class="meals-wrap">
            <table class="wide-table">
              <thead>
                <tr><th class="text-left">Repas</th><th>kcal</th><th>P</th><th>G</th><th>L</th><th>Actions</th></tr>
              </thead>
              <tbody>
                ${meals.map(m => `
                  <tr data-mealid="${m.id}">
                    <td class="td-left"><input data-field="name" value="${escapeHtml(m.name)}" /></td>
                    <td><input data-field="k" type="number" min="0" step="1" value="${round(m.k,0)}" /></td>
                    <td><input data-field="p" type="number" min="0" step="0.1" value="${round(m.p,1)}" /></td>
                    <td><input data-field="c" type="number" min="0" step="0.1" value="${round(m.c,1)}" /></td>
                    <td><input data-field="f" type="number" min="0" step="0.1" value="${round(m.f,1)}" /></td>
                    <td><button class="btn-mini btn-danger" data-action="del" type="button">Suppr.</button></td>
                  </tr>
                `).join("")}
              </tbody>
            </table>
          </div>
        `;

        wrap.querySelectorAll("input").forEach(inp => {
          inp.addEventListener("change", () => {
            const tr = inp.closest("tr");
            const id = tr.getAttribute("data-mealid");
            const field = inp.getAttribute("data-field");
            const mealsNow = getMealsForDay(dateStr);
            const idx = mealsNow.findIndex(x => x.id === id);
            if (idx < 0) return;

            const updated = { ...mealsNow[idx] };
            if (field === "name") updated.name = inp.value;
            else updated[field] = toNum(inp.value);

            mealsNow[idx] = normalizeMeal(updated);
            setMealsForDay(dateStr, mealsNow);
            syncEatenFromMeals(dateStr);
            notifyDiabProfileChanged();
        compute(true);
          });
        });

        wrap.querySelectorAll("button[data-action='del']").forEach(btn => {
          btn.addEventListener("click", () => {
            const tr = btn.closest("tr");
            const id = tr.getAttribute("data-mealid");
            const mealsNow = getMealsForDay(dateStr).filter(x => x.id !== id);
            setMealsForDay(dateStr, mealsNow);
            renderMealsTable(dateStr);
            compute(true);
          });
        });

        syncEatenFromMeals(dateStr);
      }

      function addMealFromInputs() {
        const dateStr = getSelectedDate();
        $("dayDate").value = dateStr;

        const name = $("mealName").value.trim() || "Repas";
        const m = normalizeMeal({
          name,
          k: toNum($("mealK").value),
          p: toNum($("mealP").value),
          c: toNum($("mealC").value),
          f: toNum($("mealF").value),
          createdAt: new Date().toISOString()
        });

        const mealsNow = getMealsForDay(dateStr);
        mealsNow.push(m);
        setMealsForDay(dateStr, mealsNow);

        $("mealName").value = "";
        $("mealK").value = 0; $("mealP").value = 0; $("mealC").value = 0; $("mealF").value = 0;

        renderMealsTable(dateStr);
        compute(true);
      }

      function clearMealsForDay() {
        const dateStr = getSelectedDate();
        if (!confirm(`Vider tous les repas de la journée ${dateStr} ?`)) return;
        $("dayDate").value = dateStr;
        setMealsForDay(dateStr, []);
        renderMealsTable(dateStr);
        compute(true);
      }

      function applyPer100ToMeal() {
        const k100 = toNum($("qKcal100")?.value);
        const g    = toNum($("qWeight")?.value);
        const p100 = toNum($("qP100")?.value);
        const c100 = toNum($("qC100")?.value);
        const f100 = toNum($("qF100")?.value);

        if (k100 > 0 && g > 0) $("mealK").value = round(k100 * g / 100, 0);
        if (p100 > 0 && g > 0) $("mealP").value = round(p100 * g / 100, 1);
        if (c100 > 0 && g > 0) $("mealC").value = round(c100 * g / 100, 1);
        if (f100 > 0 && g > 0) $("mealF").value = round(f100 * g / 100, 1);

          // ✅ UX: reset automatique des champs “option rapide 100g”
  ["qKcal100","qWeight","qP100","qC100","qF100"].forEach(id => {
    const el = $(id);
    if (el) el.value = "";
  });
      }

/* =====================================================================
   7) Compo corporelle + tendance 7j + historique
   UI piloté: #morningWeight #fatPct #musclePct #boneKg
             #daysHistory + boutons export/import/clear
   ===================================================================== */

      function bmiCategory(bmi) {
        if (!Number.isFinite(bmi) || bmi <= 0) return "-";
        if (bmi < 18.5) return "Insuffisance pondérale";
        if (bmi < 25)   return "Corpulence normale";
        if (bmi < 30)   return "Surpoids";
        return "Obésité";
      }

      function computeWeightStats(dateStr, daysArr) {
        const sorted = [...daysArr].sort((a,b)=>a.date.localeCompare(b.date));
        const eligible = sorted.filter(d => d.date <= dateStr && toNum(d.morningWeight) > 0);
        const last7 = eligible.slice(-7);

        if (last7.length === 0) return { avg7:null, wkVar:null };

        const avg7 = last7.reduce((s,d)=>s + toNum(d.morningWeight), 0) / last7.length;

        const prevPool = eligible.slice(0, Math.max(0, eligible.length - last7.length));
        const prev7 = prevPool.slice(-7);
        let wkVar = null;
        if (prev7.length >= 3) {
          const prevAvg = prev7.reduce((s,d)=>s + toNum(d.morningWeight), 0) / prev7.length;
          wkVar = ((avg7 - prevAvg) / prevAvg) * 100;
        }
        return { avg7, wkVar };
      }

      function safeNum(v) {
        const n = toNum(v);
        return Number.isFinite(n) ? n : 0;
      }

      function getDayEatenKcal(dayObj) {
        if (dayObj?.eaten && Number.isFinite(toNum(dayObj.eaten.k))) return safeNum(dayObj.eaten.k);
        if (Array.isArray(dayObj?.meals)) {
          return dayObj.meals.reduce((s,m)=> s + safeNum(m?.k), 0);
        }
        return 0;
      }

      function compute7dEnergyTrend(dateStr, daysArr) {
        const sorted = [...daysArr].sort((a,b)=>a.date.localeCompare(b.date));
        const eligible = sorted.filter(d => d.date <= dateStr);
        const last7 = eligible.slice(-7);

        if (last7.length === 0) {
          return {
            n: 0,
            spendAvg: null,
            eatAvg: null,
            defAvg: null,
            projWkKg: null,
            quality: { days:0, spendDays:0, eatDays:0, weightDays:0 },
            theoWkKg: null,
            realWkKg: null
          };
        }

        let spendSum = 0, spendDays = 0;
        let eatSum = 0, eatDays = 0;
        let weightDays = 0;

        for (const d of last7) {
          const spend = safeNum(d?.montreAdjusted);
          if (spend > 0) { spendSum += spend; spendDays++; }

          const eatenK = getDayEatenKcal(d);
          const hasMeals = Array.isArray(d?.meals) && d.meals.length > 0;
          if (hasMeals || eatenK > 0) { eatSum += eatenK; eatDays++; }

          if (safeNum(d?.morningWeight) > 0) weightDays++;
        }

        const spendAvg = spendDays ? (spendSum / spendDays) : null;
        const eatAvg   = eatDays ? (eatSum / eatDays) : null;
        const defAvg   = (spendAvg != null && eatAvg != null) ? (spendAvg - eatAvg) : null;

        const projWkKg = (defAvg != null) ? ((defAvg * 7) / 7700) : null;

        const eligibleWithWeight = sorted.filter(d => d.date <= dateStr && safeNum(d?.morningWeight) > 0);
        const last14w = eligibleWithWeight.slice(-14);

        let realWkKg = null;
        if (last14w.length >= 10) {
          const second7 = last14w.slice(-7);
          const first7  = last14w.slice(0, last14w.length - 7).slice(-7);

          const avgA = second7.reduce((s,d)=> s + safeNum(d.morningWeight), 0) / second7.length;
          const avgB = first7.reduce((s,d)=> s + safeNum(d.morningWeight), 0) / first7.length;

          realWkKg = (avgA - avgB);
        }

        return {
          n: last7.length,
          spendAvg, eatAvg, defAvg,
          projWkKg,
          quality: { days:last7.length, spendDays, eatDays, weightDays },
          theoWkKg: projWkKg,
          realWkKg
        };
      }

      function render7dEnergyTrendUI(dateStr) {
        const elSpend = $("avg7SpendKcal");
        const elEat   = $("avg7EatKcal");
        const elDef   = $("avg7DefKcal");
        const elProj  = $("projWkKg");
        const elCmp   = $("deltaRealVsTheo");
        const elQual  = $("dataQuality7");
        const elNote  = $("trend7Note");

        if (!elSpend || !elEat || !elDef || !elProj || !elCmp || !elQual || !elNote) return;

        const daysArr = loadDays();
        const t = compute7dEnergyTrend(dateStr, daysArr);

        if (t.n === 0) {
          elSpend.value = "-";
          elEat.value   = "-";
          elDef.value   = "-";
          elProj.value  = "-";
          elCmp.value   = "-";
          elQual.value  = "-";
          elNote.textContent = "Aucune donnée exploitable pour la tendance 7j.";
          return;
        }

        elSpend.value = (t.spendAvg == null) ? "-" : Math.round(t.spendAvg);
        elEat.value   = (t.eatAvg == null)   ? "-" : Math.round(t.eatAvg);
        elDef.value   = (t.defAvg == null)   ? "-" : Math.round(t.defAvg);

        elProj.value  = (t.projWkKg == null) ? "-" : (round(t.projWkKg, 2) + " kg/sem");

        if (t.realWkKg == null || t.theoWkKg == null) {
          elCmp.value = "-";
        } else {
          const real = t.realWkKg;
          const theo = t.theoWkKg;
          const gap  = real - theo;
          elCmp.value = `réel ${round(real,2)} vs théorique ${round(theo,2)} (écart ${round(gap,2)})`;
        }

        elQual.value = `${t.quality.days}j | dépense:${t.quality.spendDays}/7 | repas:${t.quality.eatDays}/7 | poids:${t.quality.weightDays}/7`;

       // Texte d’introduction
        let intro = "À lire sur plusieurs jours. Les variations quotidiennes sont normales.";

       // Liste des alertes
        let warnings = [];

        if (t.quality.eatDays < 5)
          warnings.push("⚠️ Peu de jours avec repas enregistrés → tendance calories moins fiable.");

        if (t.quality.spendDays < 5)
          warnings.push("⚠️ Peu de jours avec dépense corrigée → tendance dépense moins fiable.");

        if (t.quality.weightDays < 4)
          warnings.push("⚠️ Peu de mesures de poids → comparaison réel / théorique fragile.");

       // Injection HTML structurée
        elNote.innerHTML = `
         <p>${intro}</p>
           ${warnings.length ? `
            <ul class="ml11-mt04-p0">
             ${warnings.map(w => `<li>${w}</li>`).join("")}
            </ul>
         ` : ``}
        `;
      }

      function updateBodyCompUI(dateStr) {
        const d = getDay(dateStr);

        const mw = $("morningWeight");
        if (mw) mw.value = (toNum(d?.morningWeight) > 0) ? d.morningWeight : "";

        const fp = $("fatPct"); const mp = $("musclePct"); const bk = $("boneKg");
        if (fp) fp.value = (toNum(d?.fatPct) > 0) ? d.fatPct : "";
        if (mp) mp.value = (toNum(d?.musclePct) > 0) ? d.musclePct : "";
        if (bk) bk.value = (toNum(d?.boneKg) > 0) ? d.boneKg : "";

        const daysArr = loadDays();
        const { avg7, wkVar } = computeWeightStats(dateStr, daysArr);

        const a7 = $("avg7Weight"); const wv = $("wkVarPct");
        if (a7) a7.value = (avg7==null) ? "-" : round(avg7, 2);
        if (wv) wv.value = (wkVar==null) ? "-" : (round(wkVar, 2) + " %");

        const hCm = toNum($("height").value);
        const hM = hCm > 0 ? hCm / 100 : 0;
        const wMorning = toNum($("morningWeight")?.value);
        const wProfile = toNum($("weight").value);
        const wUsed = (wMorning > 0) ? wMorning : wProfile;

        let bmi = null;
        if (hM > 0 && wUsed > 0) bmi = wUsed / (hM * hM);

        const bwu = $("bmiWeightUsed"); const bv = $("bmiVal"); const bc = $("bmiCat");
        if (bwu) bwu.value = (wUsed > 0) ? round(wUsed,1) + " kg" : "-";
        if (bv) bv.value = (bmi==null) ? "-" : round(bmi, 1);
        if (bc) bc.value = (bmi==null) ? "-" : bmiCategory(bmi);

        render7dEnergyTrendUI(dateStr);
      }

      function saveBodyCompForDay(dateStr) {
        const existing = getDay(dateStr) || { date: dateStr };
        const dayObj = {
          ...existing,
          date: dateStr,
          morningWeight: (toNum($("morningWeight")?.value) > 0) ? toNum($("morningWeight").value) : null,
          fatPct: (toNum($("fatPct")?.value) > 0) ? toNum($("fatPct").value) : null,
          musclePct: (toNum($("musclePct")?.value) > 0) ? toNum($("musclePct").value) : null,
          boneKg: (toNum($("boneKg")?.value) > 0) ? toNum($("boneKg").value) : null,
          updatedAt: new Date().toISOString()
        };
        upsertDay(dayObj);
      }

      function renderDaysHistory() {
        const box = $("daysHistory");
        if (!box) return;

        const days = loadDays().sort((a,b) => b.date.localeCompare(a.date));
        if (days.length === 0) {
          box.innerHTML = "<p class='muted'>Aucune journée enregistrée (profil actif).</p>";
          return;
        }

/* === Historique des journées === */

        box.innerHTML = `
          <div class="table-wrap">
            <table class="history-table">
              <thead>
                <tr>
                  <th>Date</th>
                  <th>Poids</th>
                  <th>Montre</th>
                  <th>Dépense corrigée</th>
                  <th>Régime</th>
                  <th>Objectif %</th>
                  <th>Cible kcal</th>
                  <th>Repas</th>
                  <th>Actions</th>
                </tr>
              </thead>
              <tbody>
                ${days.map(d => {
                  const goal = (d.goalPct != null) ? d.goalPct : 0;
                  return `
                    <tr>
                      <td>${d.date}</td>
                      <td>${(toNum(d.morningWeight)>0) ? round(d.morningWeight,1) : "-"}</td>
                      <td>${Math.round(d.montreRaw ?? 0)}</td>
                      <td>${Math.round(d.montreAdjusted ?? 0)}</td>
                      <td>${escapeHtml(dietLabel(d.dietMode))}</td>
                      <td>${Math.round(goal ?? 0)}%</td>
                      <td>${Math.round(d.targetKcal ?? 0)}</td>
                      <td>${Array.isArray(d.meals) ? d.meals.length : 0}</td>
                      <td><button class="btn-mini btn-danger"
        data-action="del-day"
        data-date="${escapeHtml(d.date)}"
        type="button">Suppr.</button></td>
                    </tr>
                  `;
                }).join("")}
              </tbody>
            </table>
          </div>
        `;
      }

      function loadDayIntoForm(dateStr) {
        const d = getDay(dateStr);
        if (!d) return;
        $("dayDate").value = d.date;

        if (d.watchBrand) $("watchBrand").value = d.watchBrand;
        applyBrandPreset($("watchBrand").value, false);

        if (d.montreRaw != null) $("montre").value = d.montreRaw;
        if (d.errPct != null && $("errPct")) $("errPct").value = d.errPct;
        if (d.errMode && $("errMode")) $("errMode").value = d.errMode;

        if (d.dietMode && $("dietMode")) $("dietMode").value = d.dietMode;

        if (d.goalPct != null && $("goalPct")) $("goalPct").value = d.goalPct;
        if (d.protPerKg != null && $("protPerKg")) $("protPerKg").value = d.protPerKg;
        if (d.fatPerKg != null && $("fatPerKg")) $("fatPerKg").value = d.fatPerKg;

        if ($("dietMode")) setDietNote($("dietMode").value, false);

        renderMealsTable(d.date);
        updateBodyCompUI(d.date);

loadSportSleepIntoUI(dateStr);
renderSportSleep7d(dateStr);

        compute(true);
      }

function getSportSleepForDay(dateStr){
  const d = getDay(dateStr) || { date: dateStr };
  const sport = d.sport || {};
  const sleep = d.sleep || {};
  return {
    sport: {
      minutes: Math.max(0, toNum(sport.minutes) || 0),
      kcal: Math.max(0, toNum(sport.kcal) || 0),
      type: String(sport.type || "")
    },
    sleep: {
      hours: Math.max(0, toNum(sleep.hours) || 0),
      score: Math.max(0, toNum(sleep.score) || 0),
      bed: String(sleep.bed || ""),
      wake: String(sleep.wake || "")
    }
  };
}

function loadSportSleepIntoUI(dateStr){
  const ss = getSportSleepForDay(dateStr);
  if ($("sportMin")) $("sportMin").value = ss.sport.minutes || 0;
  if ($("sportKcal")) $("sportKcal").value = ss.sport.kcal || 0;
  if ($("sportType")) $("sportType").value = ss.sport.type || "";

  if ($("sleepH")) $("sleepH").value = ss.sleep.hours || 0;
  if ($("sleepScore")) $("sleepScore").value = ss.sleep.score || 0;
  if ($("sleepBed")) $("sleepBed").value = ss.sleep.bed || "";
  if ($("sleepWake")) $("sleepWake").value = ss.sleep.wake || "";
}

function saveSportSleepForDay(dateStr){
  const existing = getDay(dateStr) || { date: dateStr };
  const dayObj = {
    ...existing,
    date: dateStr,
    sport: {
      minutes: Math.max(0, toNum($("sportMin")?.value) || 0),
      kcal: Math.max(0, toNum($("sportKcal")?.value) || 0),
      type: String($("sportType")?.value || "").trim()
    },
    sleep: {
      hours: Math.max(0, toNum($("sleepH")?.value) || 0),
      score: Math.max(0, toNum($("sleepScore")?.value) || 0),
      bed: String($("sleepBed")?.value || ""),
      wake: String($("sleepWake")?.value || "")
    },
    updatedAt: new Date().toISOString()
  };
  upsertDay(dayObj);
}

function getLastNDays(dateStr, n=7){
  // jours <= dateStr, triés asc (simple)
  const days = loadDays().filter(d => d?.date && d.date <= dateStr).sort((a,b)=>a.date.localeCompare(b.date));
  return days.slice(-n);
}

function computeSportSleep7d(dateStr){
  const arr = getLastNDays(dateStr, 7);

  let sportMin = 0, sportK = 0, sportDays = 0;
  let sleepH = 0, sleepDays = 0;
  let intenseDays = 0, shortSleepDays = 0;

  arr.forEach(d=>{
    const s = d.sport || {};
    const sl = d.sleep || {};

    const m = Math.max(0, toNum(s.minutes) || 0);
    const k = Math.max(0, toNum(s.kcal) || 0);
    if (m > 0 || k > 0) sportDays++;
    sportMin += m; sportK += k;

    const h = Math.max(0, toNum(sl.hours) || 0);
    if (h > 0) sleepDays++;
    sleepH += h;

    // drapeaux (à calibrer ensuite)
    if (k >= 700 || m >= 90) intenseDays++;
    if (h > 0 && h < 6.0) shortSleepDays++;
  });

  return {
    n: arr.length,
    sportMin, sportK, sportDays,
    sleepH, sleepDays,
    intenseDays, shortSleepDays,
    avgSportMin: sportDays ? (sportMin / sportDays) : 0,
    avgSportK: sportDays ? (sportK / sportDays) : 0,
    avgSleepH: sleepDays ? (sleepH / sleepDays) : 0
  };
}

function renderSportSleep7d(dateStr){
  const box = $("sportSleep7d");
  if (!box) return;

  const s = computeSportSleep7d(dateStr);

  const flags = [];
  if (s.intenseDays >= 3) flags.push("⚑ 3+ jours intenses");
  if (s.shortSleepDays >= 2) flags.push("⚑ 2+ nuits courtes");
  if (s.intenseDays >= 3 && s.shortSleepDays >= 2) flags.push("⚑ combo charge + sommeil court");

  box.innerHTML = `
    <div class="card" style="border:1px dashed #ddd">
      <b>Synthèse 7 jours</b>
      <div class="muted mt-025">
        Sport: ${Math.round(s.sportMin)} min • ${Math.round(s.sportK)} kcal (sur ${s.sportDays} j)<br/>
        Sommeil: ${round(s.avgSleepH,1)} h de moyenne (sur ${s.sleepDays} j)
        ${flags.length ? "<br/><br/>" + flags.join(" • ") : ""}
      </div>
    </div>
  `;
}


/* =====================================================================
   8) Viz calories (panneau pédagogique)
   UI piloté: #calFlowCard, #barP/#barC/#barF, #flow_* champs
   ===================================================================== */
      function updateCalorieFlowViz(ctx){
        const card = $("calFlowCard");
        if (!card) return;

        const {
          targetKcal=0,
          montreAdjusted=0,
          goalPct=0,
          w=0,

          // macros finaux
          targetP=0, targetC=0, targetF=0,

          // valeurs de base (avant redistribution)
          protPerKg=0,
          fatPerKgEff=0,
          targetFbase=0,      // lipides "plancher" en g
          targetCraw=0,       // glucides "théoriques" (kcal restantes) en g

          // carb-guard
          carbGuardEnabled=false,
          carbCapG=null,      // cap final (g/j) si actif, sinon null
          kcalRemaining=0,    // kcal déplacées vers les lipides (si cap)

          // low-carb
          lowCarbEnabled=false,
          lowCarbKg=0,
          lowCarbLevel="",
          lowCarbImpossible=false
        } = (ctx || {});

        const tK = Math.max(0, targetKcal);
        const spend = Math.max(0, montreAdjusted);

        const pG = Math.max(0, targetP);
        const cG = Math.max(0, targetC);
        const fG = Math.max(0, targetF);

        const pK = pG * 4;
        const cK = cG * 4;
        const fK = fG * 9;

        const pct = (k) => (tK > 0 ? clamp((k / tK) * 100, 0, 100) : 0);
        const setBar = (id, k) => {
          const el = $(id);
          if (!el) return;
          el.style.width = pct(k).toFixed(1) + "%";
        };
        const setTxt = (id, v) => { const el=$(id); if(el) el.textContent = v; };

        // Delta cible - dépense (pédagogie : déficit/surplus vs dépense corrigée)
        const delta = tK - spend;
        const deltaPill = $("flow_deltaKcal");
        if (deltaPill){
          const cls = delta < -50 ? "warn" : (Math.abs(delta) <= 50 ? "ok" : "");
          deltaPill.classList.remove("warn","ok");
          if (cls) deltaPill.classList.add(cls);
          const sign = delta > 0 ? "+" : "";
          deltaPill.textContent = `${sign}${round(delta,0)} kcal`;
        }

        // Remplissage valeurs principales
        setTxt("flow_targetKcal", round(tK,0));
        setTxt("flow_spendKcal", round(spend,0));

        setTxt("flow_pKcal", `${round(pK,0)} kcal`);
        setTxt("flow_cKcal", `${round(cK,0)} kcal`);
        setTxt("flow_fKcal", `${round(fK,0)} kcal`);

        setBar("barP", pK);
        setBar("barC", cK);
        setBar("barF", fK);

        setTxt("flow_pG", round(pG,1));
        setTxt("flow_cG", round(cG,1));
        setTxt("flow_fG", round(fG,1));

        // Etat / explication : cap glucides ou low-carb
        const capState = $("flow_capState");
        const capActive = (!!carbGuardEnabled && carbCapG != null && Number.isFinite(carbCapG) && carbCapG > 0);

        if (capState){
          capState.classList.remove("warn","ok");

          if (lowCarbEnabled){
            const lvl = (lowCarbLevel === "strict") ? "strict" : (lowCarbLevel === "moderate" ? "modéré" : "");
            capState.textContent = `Mode low-carb : ${lvl} (≈ ${round(lowCarbKg,2)} g/kg/j)`;
            capState.classList.add(lowCarbImpossible ? "warn" : "ok");
          } else if (!capActive){
            capState.textContent = "Plafond glucides : OFF";
          } else {
            const atCap = (cG >= carbCapG - 0.5);
            capState.textContent = atCap
              ? `Plafond glucides : ATTEINT (≈ ${round(carbCapG,0)} g/j)`
              : `Plafond glucides : actif (≈ ${round(carbCapG,0)} g/j)`;
            capState.classList.add(atCap ? "warn" : "ok");
          }
        }

        // Bloc "si cap atteint" (ou low-carb)
        const capG = capActive ? Math.max(0, carbCapG) : 0;
        const cTheoG = Math.max(0, targetCraw);        // glucides théoriques (sans cap / sans low-carb)
        const fBaseG = Math.max(0, targetFbase);       // lipides plancher en g
        const shiftK = Math.max(0, kcalRemaining);     // kcal déplacées (carb-guard)

        // En low-carb : on explique en écart vs "théorique"
        let shiftK2 = shiftK;
        if (lowCarbEnabled){
          const diffC = Math.max(0, (cTheoG - cG)); // glucides "retirés" vs théorie
          shiftK2 = diffC * 4; // kcal libérées par le retrait de glucides
        }

        const fExtraG = Math.max(0, fG - fBaseG);

        setTxt("flow_capG", (lowCarbEnabled ? `${round(cG,0)} g/j (fixé)` : (capActive ? `${round(capG,0)} g/j` : "—")));
        setTxt("flow_cTheoG", round(cTheoG,1));
        setTxt("flow_shiftKcal", round(shiftK2,0));
        setTxt("flow_fBaseG", round(fBaseG,1));
        setTxt("flow_fExtraG", round(fExtraG,1));

        // Griser si aucun régime
        card.style.opacity = ($("dietMode")?.value === "none") ? .55 : 1;
      }

/* =====================================================================
   9) Diabète (UI rapide + reco + historique diab)
   UI piloté: #diabEnabled, #diabPanelInRepas, boutons reco, etc.
   ===================================================================== */
     function diab_isEnabled(){ return !!($("diabEnabled")?.checked); }
        let __diabUIBusy = false;

    /** Verrouille/déverrouille l'encart "Option diabète — repères glucides" (UI only) */
function diab_setQuickPanelLocked(locked){
  const panel = $("diabPanelInRepas");
  if (!panel) return;
  panel.classList.toggle("is-disabled", !!locked);

  // Inputs read-only : on laisse disabled quand OFF, on les passe en readonly quand ON
  panel.querySelectorAll("input, select, button, textarea").forEach(el => {
    // On n'active pas les champs de saisie inexistants ici: uniquement lecture
    if (el.tagName === "INPUT" || el.tagName === "SELECT" || el.tagName === "TEXTAREA"){
      if (locked){
        el.setAttribute("disabled","disabled");
        el.classList.add("is-locked");
      }else{
        el.removeAttribute("disabled");
        el.classList.remove("is-locked");
        // empêcher la saisie: readonly pour inputs texte/num
        if (el.tagName === "INPUT") el.setAttribute("readonly","readonly");
      }
    }else if (el.tagName === "BUTTON"){
      // boutons de raccourci actifs seulement si ON
      el.disabled = !!locked;
    }
  });

  const pill = $("diabQuickStatus");
  if (pill) pill.textContent = locked ? "(Désactivé)" : "(Activé)";
}

let __diabLastPushedCarbs = null;

/** Met à jour les mini-indicateurs (issus des repas V1 + glycémies diabète) */
function diab_updateQuickKpis(dateStr){
  // anti-boucle: n'entraîne jamais compute()
  const on = diab_isEnabled();

  // Totaux repas V1 (déjà calculés et affichés dans le tableau Résultats)
  // On lit les champs déjà existants si présents (ne touche pas au moteur).
  const carbs = isFinite(toNum($("eatenC")?.value)) ? toNum($("eatenC")?.value) : toNum($("tC")?.value);  // priorité: "Déjà consommé" (repas)
  const cap   = toNum($("carbCeil")?.value || $("carbGuardCeil")?.value || $("carbGuardPillar")?.value); // si tu as un champ plafond existant

  // Dernière glycémie du jour: on lit la table glycémies si elle existe
  
  let lastTxt = "—";
  try{
    const d = dateStr || getSelectedDate?.() || "";
    const arr = (typeof diab_getGlucoseForDay === "function") ? diab_getGlucoseForDay(d) : [];
    if (arr && arr.length){
      const last = arr[arr.length-1];
      const unit = ($("diab_unit")?.value || "mgdl");
      if (last && isFinite(last.mgdl)){
        if (unit === "mmol"){
          lastTxt = round(diab_mgdlToMmol(last.mgdl), 1) + " mmol/L";
        }else{
          lastTxt = round(last.mgdl, 0) + " mg/dL";
        }
      }
    }
  }catch(e){ /* silence */ }
const setV = (id, v) => { const el=$(id); if(el) el.value = v; };

  // OFF -> on affiche "-" mais on n'efface rien côté stockage
  setV("diabQuickCarbG", on ? (isFinite(carbs)? String(round(carbs,1)) : "-") : "-");
const pushed = toNum($("diabQuickCarbG")?.value);
if (__diabLastPushedCarbs !== pushed){
  __diabLastPushedCarbs = pushed;
  try{
    const ev = new CustomEvent("diab:carbs-pushed", {
      detail: { date: dateStr || (getSelectedDate?.() || ""), carbsG: pushed }
    });
    window.dispatchEvent(ev);
  }catch(e){}
}

  setV("diabQuickLastG", on ? lastTxt : "-");

  const line = $("diabQuickLine");
  if (line){
    if (!on){
      line.textContent = "Option diabète désactivée : activer pour afficher zones, plafond et alertes.";
    }else{
      const capTxt = (isFinite(cap) && cap>0) ? ` • plafond ${round(cap,0)} g/j` : "";
      line.textContent = `(activés)${capTxt}.`;
    }
  }

  // Recos low-carb / Repères glucidiques
  const rec = $("diabQuickReco");
  if (rec){
    const lowOn = !!$("lowCarbEnabled")?.checked;
    const guardOn = !!$("carbGuardEnabled")?.checked;
    rec.classList.toggle("hidden", !on);
const txt = $("diabQuickRecoText");
    if (txt){
      if (!on) txt.textContent = "";
      else{
        const parts = [];
        if (!lowOn && !guardOn){
          parts.push("Pour réduire ou encadrer les glucides, active Low-carb ou Repères dans la section « Repères glucidiques ».");
        } else if (!lowOn){
          parts.push("Pour réduire davantage les glucides, active l’option Low-carb dans « Repères glucidiques ».");
        } else if (!guardOn){
          parts.push("Pour encadrer la journée, active l’option Repères dans « Repères glucidiques ».");
        } else {
          parts.push("Low-carb et/ou Repères sont actifs : ajuste les paramètres dans « Repères glucidiques » si besoin.");
        }
        parts.push("Ces options restent facultatives et n’affectent pas l’historique si tu ne les touches pas.");
        txt.textContent = parts.join(" ");
      }
    }
}
}

/** Active/désactive le mode diabète (UI + recommandations). Ne modifie pas le moteur V1. */
function applyDiabMode(enabled){
  const on = !!enabled;

  // Affichage du menu diabète
  const item = $("diabMenuItem");
  if (item) item.classList.toggle("hidden", !on);

  // Si on désactive alors qu'on est sur l'onglet diabète -> retour dashboard
  const current = document.body.getAttribute("data-tab") || "";
  if (!on && current === "diab"){
    setActiveTab("dash");
  }

  diab_setQuickPanelLocked(!on);
  diab_setHistoryLocked(!on);
  diab_refreshHistoryUI(!on);

  // Cache sur la page diabète: on garde uniquement journal + contexte
  $("diabBlocksWrap")?.classList.add("hidden"); // repas+historique diabètes inutiles (repas gérés sur page Repas)
  $("diabBlocksHome")?.classList.add("hidden");

  // Rafraîchir affichage
  diab_updateQuickKpis(getSelectedDate?.() || "");
}


function diab_deleteAllHistory(){
  const days = loadDays();
  let n = 0;

  for (const d of days){
    if (!d?.date) continue;
    if (!d.diabGlucose && !d.diabMeta && !d.diabMeals) continue;

    const dayObj = { ...d };
    delete dayObj.diabGlucose;
    delete dayObj.diabMeta;
    delete dayObj.diabMeals;
    dayObj.updatedAt = new Date().toISOString();
    upsertDay(dayObj);
    n++;
  }
  return n;
}

      function notifyDiabProfileChanged(){
        const frame = $("diabFrame");
        try{
          frame?.contentWindow?.postMessage({ type:"PROFILE_CHANGED" }, "*");
        } catch(e){}
      }

/* =========================================================
   HISTORIQUE JOURNÉE — DIABÈTE (page Suivi)
   - Visible seulement si option diabète activée
   - Sauvegarde: réutilise le stockage "day" (loadDays/upsertDay)
   - Ne touche pas au moteur V1
   ========================================================= */
function diab_setHistoryLocked(locked){
  const body = $("diabHistoryBody");
  const msg  = $("diabHistoryLockMsg");
  if (body) body.classList.toggle("diab-locked", !!locked);
  if (msg)  msg.classList.toggle("hidden", !locked);
}

function diab_refreshHistoryUI(){
  // Render tableau historique diabète dans Suivi (si présent)
  if ($("diab_daysHistory_suivi")){
    diab_renderDaysHistory("diab_daysHistory_suivi");
  }
}

function diab_deleteDiabDataForDay(dateStr){
  const d = getDay(dateStr);
  if (!d) return;
  // On supprime uniquement les données diabète (journal + meta), sans toucher aux repas V1.
  const dayObj = { ...d };
  delete dayObj.diabGlucose;
  delete dayObj.diabMeta;
  delete dayObj.diabMeals; // si jamais existait dans d'anciennes versions
  dayObj.updatedAt = new Date().toISOString();
  upsertDay(dayObj);

  // Rafraîchir affichages (si l'utilisateur est sur la même date)
  const cur = getSelectedDate?.() || "";
  if (cur && cur === dateStr){
    try{ diab_renderGlucoseTable(cur); }catch(e){}
    try{ diab_renderDayKpis(cur); }catch(e){}
    try{ diab_refreshHistoryUI(); }catch(e){}
  }
}

function diab_deleteDiabHistoryRow(dateStr){
  const d = getDay(dateStr);
  if (!d) return;

  // Supprime UNIQUEMENT les données diabète de la journée (historique diabète),
  // sans toucher aux repas V1 stockés dans d.meals
  const dayObj = { ...d };

  delete dayObj.diabGlucose;
  delete dayObj.diabMeta;
  delete dayObj.diabSettings;
  delete dayObj.diabMeals; // au cas où legacy

  dayObj.updatedAt = new Date().toISOString();
  upsertDay(dayObj);

  // Si on est sur la même date, on rafraîchit les panneaux diabète
  const cur = getSelectedDate?.() || "";
  if (cur === dateStr){
    try{ diab_renderGlucoseTable(cur); }catch(e){}
    try{ diab_renderDayKpis(cur); }catch(e){}
  }
  try{ diab_renderDaysHistory(); }catch(e){}
  try{ diab_refreshHistoryUI?.(); }catch(e){}
}


function diab_initHistorySuivi(){
  const inp = $("diabHistDate");
  const del = $("btnDiabDeleteDay");
  const ref = $("btnDiabHistRefresh");

  if (inp){
    inp.value = getSelectedDate?.() || new Date().toISOString().slice(0,10);
    inp.addEventListener("change", () => {
      // On synchronise la date globale de l'app pour cohérence UX
      const v = inp.value;
      if ($("dayDate")) $("dayDate").value = v;
      try{ loadDayIntoForm(v); }catch(e){}
      try{ compute(true); }catch(e){}
      try{ diab_renderGlucoseTable(v); }catch(e){}
      try{ diab_renderDayKpis(v); }catch(e){}
      try{ diab_refreshHistoryUI(v); }catch(e){}
    });
  }

if (del){
  del.addEventListener("click", () => {
    if (!confirm("Supprimer TOUT l’historique diabète (toutes dates) ?")) return;

    const n = diab_deleteAllHistory();
    diab_refreshHistoryUI();
    alert(n ? `Historique diabète supprimé (${n} journée(s)).` : "Aucune donnée diabète à supprimer.");
  });
}


  if (ref){
    ref.addEventListener("click", () => {
      diab_refreshHistoryUI();
    });
  }
}


/* =========================
   Diabète — module intégré
   (stocké dans dayObj: diabMeta, diabMeals, diabGlucose + diabSettings)
   ========================= */

function diab_mgdlToMmol(mgdl){ return mgdl / 18; }
function diab_mmolToMgdl(mmol){ return mmol * 18; }

function diab_displayGlucose(valueMgdl, unit){
  if (!Number.isFinite(valueMgdl) || valueMgdl <= 0) return "-";
  return (unit === "mmol") ? round(diab_mgdlToMmol(valueMgdl), 1) : round(valueMgdl, 0);
}

function diab_parseGlucoseInput(v, unit){
  const x = toNum(v);
  if (x <= 0) return 0;
  return (unit === "mmol") ? diab_mmolToMgdl(x) : x; // store mg/dL
}

function diab_getSettings(){
  const d = getDay(getSelectedDate());
  const s = d?.diabSettings || null;
  return {
    glucoseUnit: s?.glucoseUnit || "mgdl",
    carbPortionG: Math.max(5, toNum(s?.carbPortionG || 15))
  };
}

function diab_saveSettings(){
  const dateStr = getSelectedDate();
  const existing = getDay(dateStr) || { date: dateStr };
  const settings = {
    glucoseUnit: ($("diab_glucoseUnit")?.value || "mgdl"),
    updatedAt: new Date().toISOString()
  };
  const dayObj = { ...existing, date: dateStr, diabSettings: settings, updatedAt: new Date().toISOString() };
  upsertDay(dayObj);
  return settings;
}


function diab_normalizeMeta(meta){
  const sick = String(meta?.sick ?? "");
  const alcohol = String(meta?.alcohol ?? "");

  // HbA1c (optionnel)
  const hba1cRaw = (meta?.hba1c ?? "");
  const hba1cNum = (String(hba1cRaw).trim() !== "" && Number.isFinite(toNum(hba1cRaw)))
    ? clamp(toNum(hba1cRaw), 3, 20)
    : null;

  const hba1cDate = String(meta?.hba1cDate ?? "").trim();

  return {
    activity: String(meta?.activity ?? "").trim(),
    stress: (String(meta?.stress).trim() !== "" && Number.isFinite(toNum(meta?.stress))) ? clamp(toNum(meta.stress), 0, 10) : null,
    sleepH:  (String(meta?.sleepH).trim() !== "" && Number.isFinite(toNum(meta?.sleepH))) ? clamp(toNum(meta.sleepH), 0, 24) : null,
    sick: (sick === "yes" || sick === "no") ? sick : "",
    alcohol: (alcohol === "yes" || alcohol === "no") ? alcohol : "",
    note: String(meta?.note ?? "").trim(),

    // NEW
    hba1c: hba1cNum,
    hba1cDate: hba1cDate
  };
}



function diab_loadMetaIntoUI(dateStr){
  const d = getDay(dateStr);
  const meta = diab_normalizeMeta(d?.diabMeta || {});
  if ($("diab_dayActivity")) $("diab_dayActivity").value = meta.activity || "";
  if ($("diab_dayStress")) $("diab_dayStress").value = (meta.stress==null) ? "" : meta.stress;
  if ($("diab_daySleepH")) $("diab_daySleepH").value = (meta.sleepH==null) ? "" : meta.sleepH;
  if ($("diab_daySick")) $("diab_daySick").value = meta.sick || "";
  if ($("diab_dayAlcohol")) $("diab_dayAlcohol").value = meta.alcohol || "";
  if ($("diab_dayNoteFree")) $("diab_dayNoteFree").value = meta.note || "";

  // NEW
  if ($("diab_hba1c")) $("diab_hba1c").value = (meta.hba1c==null) ? "" : round(meta.hba1c,1);
  if ($("diab_hba1cDate")) $("diab_hba1cDate").value = meta.hba1cDate || "";
}

function diab_saveMetaFromUI(dateStr){
  const existing = getDay(dateStr) || { date: dateStr };
  const meta = diab_normalizeMeta({
    activity: $("diab_dayActivity")?.value,
    stress: $("diab_dayStress")?.value,
    sleepH: $("diab_daySleepH")?.value,
    sick: $("diab_daySick")?.value,
    alcohol: $("diab_dayAlcohol")?.value,
    note: $("diab_dayNoteFree")?.value,

    // NEW
    hba1c: $("diab_hba1c")?.value,
    hba1cDate: $("diab_hba1cDate")?.value
  });
  const dayObj = { ...existing, date: dateStr, diabMeta: meta, updatedAt: new Date().toISOString() };
  upsertDay(dayObj);
}


function diab_normalizeMeal(m){
  const carb = Math.max(0, toNum(m.carb));
  const fiber = Math.max(0, toNum(m.fiber));
  const sugar = Math.max(0, toNum(m.sugar));
  const net = Math.max(0, carb - fiber);
  return {
    id: m.id || crypto.randomUUID?.() || String(Date.now() + Math.random()),
    name: String(m.name ?? "").trim() || "Repas",
    carb, fiber, sugar,
    net,
    note: String(m.note ?? "").trim(),
    createdAt: m.createdAt || new Date().toISOString()
  };
}

function diab_getMealsForDay(dateStr){
  const d = getDay(dateStr);
  return Array.isArray(d?.diabMeals) ? d.diabMeals.map(diab_normalizeMeal) : [];
}

function diab_setMealsForDay(dateStr, meals){
  const existing = getDay(dateStr) || { date: dateStr };
  const dayObj = { ...existing, date: dateStr, diabMeals: meals.map(diab_normalizeMeal), updatedAt: new Date().toISOString() };
  upsertDay(dayObj);
}

function diab_mealsTotals(meals){
  return meals.reduce((acc, m) => {
    acc.carb += toNum(m.carb);
    acc.fiber += toNum(m.fiber);
    acc.sugar += toNum(m.sugar);
    acc.net += Math.max(0, toNum(m.carb) - toNum(m.fiber));
    return acc;
  }, { carb:0, fiber:0, sugar:0, net:0 });
}

function diab_renderMealsTable(dateStr){
  const meals = diab_getMealsForDay(dateStr).sort((a,b)=> (a.createdAt||"").localeCompare(b.createdAt||""));
  const wrap = $("diab_mealsTableWrap");
  if (!wrap) return;

  const settings = diab_getSettings();
  const portionG = Math.max(5, toNum(settings.carbPortionG)) || 15;

  if (meals.length === 0){
    wrap.innerHTML = `<p class="muted">Aucun repas encodé pour cette journée.</p>`;
    return;
  }

  wrap.innerHTML = `
    <div class="table-wrap">
      <table>
        <thead>
          <tr>
            <th style="text-align:left">Repas</th>
            <th>Glucides (g)</th>
            <th>Portions</th>
            <th style="text-align:left">Note</th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody>
          ${meals.map(m => {
            const net = Math.max(0, toNum(m.carb) - toNum(m.fiber));
            const portions = portionG > 0 ? (net / portionG) : 0;
            return `
              <tr data-mealid="${m.id}">
                <td class="td-left"><input data-field="name" value="${escapeHtml(m.name)}" /></td>
                <td><input data-field="carb" type="number" min="0" step="0.1" value="${round(m.carb,1)}" /></td>
                <td><input data-field="fiber" type="number" min="0" step="0.1" value="${round(m.fiber,1)}" /></td>
                <td><input data-field="sugar" type="number" min="0" step="0.1" value="${round(m.sugar,1)}" /></td>
                <td><b>${round(net,1)}</b></td>
                <td>${round(portions,2)}</td>
                <td class="td-left"><input data-field="note" value="${escapeHtml(m.note)}" /></td>
                <td><button class="btn-mini btn-danger" data-action="del">Suppr.</button></td>
              </tr>
            `;
          }).join("")}
        </tbody>
      </table>
    </div>
  `;

  wrap.querySelectorAll("input").forEach(inp => {
    inp.addEventListener("change", () => {
      const tr = inp.closest("tr");
      const id = tr.getAttribute("data-mealid");
      const field = inp.getAttribute("data-field");
      const mealsNow = diab_getMealsForDay(dateStr);
      const idx = mealsNow.findIndex(x => x.id === id);
      if (idx < 0) return;

      const updated = { ...mealsNow[idx] };
      if (field === "name" || field === "note") updated[field] = inp.value;
      else updated[field] = toNum(inp.value);

      mealsNow[idx] = diab_normalizeMeal(updated);
      diab_setMealsForDay(dateStr, mealsNow);

      diab_renderMealsTable(dateStr);
      diab_renderDayKpis(dateStr);
    });
  });

  wrap.querySelectorAll("button[data-action='del']").forEach(btn => {
    btn.addEventListener("click", () => {
      const tr = btn.closest("tr");
      const id = tr.getAttribute("data-mealid");
      const mealsNow = diab_getMealsForDay(dateStr).filter(x => x.id !== id);
      diab_setMealsForDay(dateStr, mealsNow);
      diab_renderMealsTable(dateStr);
      diab_renderDayKpis(dateStr);
    });
  });
}

function diab_addMealFromInputs(){
  const dateStr = getSelectedDate();
  const m = diab_normalizeMeal({
    name: $("diab_mealName")?.value?.trim() || "Repas",
    carb: toNum($("diab_mealCarb")?.value),
    fiber: toNum($("diab_mealFiber")?.value),
    sugar: toNum($("diab_mealSugar")?.value),
    note: $("diab_mealNote")?.value?.trim() || "",
    createdAt: new Date().toISOString()
  });

  const mealsNow = diab_getMealsForDay(dateStr);
  mealsNow.push(m);
  diab_setMealsForDay(dateStr, mealsNow);

  if ($("diab_mealName")) $("diab_mealName").value = "";
  if ($("diab_mealCarb")) $("diab_mealCarb").value = 0;
  if ($("diab_mealFiber")) $("diab_mealFiber").value = 0;
  if ($("diab_mealSugar")) $("diab_mealSugar").value = 0;
  if ($("diab_mealNote")) $("diab_mealNote").value = "";

  diab_renderMealsTable(dateStr);
  diab_renderDayKpis(dateStr);
}

function diab_clearMealsForDay(){
  const dateStr = getSelectedDate();
  diab_setMealsForDay(dateStr, []);
  diab_renderMealsTable(dateStr);
  diab_renderDayKpis(dateStr);
}

function diab_applyPer100ToMeal(){
  const c100  = toNum($("diab_qC100")?.value);
  const fi100 = toNum($("diab_qFi100")?.value);
  const su100 = toNum($("diab_qSu100")?.value);
  const g     = toNum($("diab_qWeight")?.value);

  if (g > 0 && c100 >= 0 && $("diab_mealCarb")) $("diab_mealCarb").value = round(c100 * g / 100, 1);
  if (g > 0 && fi100 >= 0 && $("diab_mealFiber")) $("diab_mealFiber").value = round(fi100 * g / 100, 1);
  if (g > 0 && su100 >= 0 && $("diab_mealSugar")) $("diab_mealSugar").value = round(su100 * g / 100, 1);
}

function diab_normalizeGlucose(x){
  const mgdl = Math.max(0, toNum(x.mgdl));
  return {
    id: x.id || crypto.randomUUID?.() || String(Date.now() + Math.random()),
    mgdl,
    context: String(x.context ?? "").trim() || "autre",
    time: String(x.time ?? "").trim(),
    note: String(x.note ?? "").trim(),
    createdAt: x.createdAt || new Date().toISOString()
  };
}

function diab_getGlucoseForDay(dateStr){
  const d = getDay(dateStr);
  return Array.isArray(d?.diabGlucose) ? d.diabGlucose.map(diab_normalizeGlucose) : [];
}

function diab_setGlucoseForDay(dateStr, items){
  const existing = getDay(dateStr) || { date: dateStr };
  const dayObj = { ...existing, date: dateStr, diabGlucose: items.map(diab_normalizeGlucose), updatedAt: new Date().toISOString() };
  upsertDay(dayObj);
}

function diab_renderGlucoseTable(dateStr){
  const unit = $("diab_glucoseUnit")?.value || diab_getSettings().glucoseUnit || "mgdl";
  const items = diab_getGlucoseForDay(dateStr).sort((a,b)=> (a.createdAt||"").localeCompare(b.createdAt||""));
  const wrap = $("diab_glucoseTableWrap");
  if (!wrap) return;

  if (items.length === 0){
    wrap.innerHTML = `<p class="muted">Aucune glycémie encodée pour cette journée.</p>`;
    return;
  }

  wrap.innerHTML = `
    <div class="table-wrap">
      <table>
        <thead>
          <tr>
            <th>Heure</th>
            <th>Moment</th>
            <th>Valeur (${unit === "mmol" ? "mmol/L" : "mg/dL"})</th>
            <th style="text-align:left">Note</th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody>
          ${items.map(g => `
            <tr data-gid="${g.id}">
              <td><input data-field="time" type="time" value="${escapeHtml(g.time)}" /></td>
              <td>
                <select data-field="context">
                  ${["à jeun","avant repas","2h après repas","coucher","nuit / réveil hypo","avant sport","après sport","autre"]
                    .map(opt => `<option value="${escapeHtml(opt)}" ${opt===g.context?"selected":""}>${escapeHtml(opt)}</option>`)
                    .join("")}
                </select>
              </td>
              <td>
                <input data-field="value" type="number" min="0" step="${unit==="mmol" ? "0.1":"1"}"
                       value="${diab_displayGlucose(g.mgdl, unit)}" />
              </td>
              <td class="td-left"><input data-field="note" value="${escapeHtml(g.note)}" /></td>
              <td><button class="btn-mini btn-danger" data-action="del">Suppr.</button></td>
            </tr>
          `).join("")}
        </tbody>
      </table>
    </div>
  `;

  wrap.querySelectorAll("input,select").forEach(el => {
    el.addEventListener("change", () => {
      const tr = el.closest("tr");
      const id = tr.getAttribute("data-gid");
      const field = el.getAttribute("data-field");
      const now = diab_getGlucoseForDay(dateStr);
      const idx = now.findIndex(x => x.id === id);
      if (idx < 0) return;

      const updated = { ...now[idx] };
      if (field === "context") updated.context = el.value;
      else if (field === "time") updated.time = el.value;
      else if (field === "note") updated.note = el.value;
      else if (field === "value") updated.mgdl = diab_parseGlucoseInput(el.value, unit);

      now[idx] = diab_normalizeGlucose(updated);
      diab_setGlucoseForDay(dateStr, now);
      diab_renderDayKpis(dateStr);
      diab_renderDaysHistory();
    });
  });

  wrap.querySelectorAll("button[data-action='del']").forEach(btn => {
    btn.addEventListener("click", () => {
      const tr = btn.closest("tr");
      const id = tr.getAttribute("data-gid");
      const now = diab_getGlucoseForDay(dateStr).filter(x => x.id !== id);
      diab_setGlucoseForDay(dateStr, now);
      diab_renderGlucoseTable(dateStr);
      diab_renderDayKpis(dateStr);
      diab_renderDaysHistory();
    });
  });
}

function diab_addGlucoseFromInputs(){
  const dateStr = getSelectedDate();
  const unit = $("diab_glucoseUnit")?.value || "mgdl";
  const mgdl = diab_parseGlucoseInput($("diab_gValue")?.value, unit);
  if (mgdl <= 0) { alert("Entre une valeur > 0."); return; }

  const entry = diab_normalizeGlucose({
    mgdl,
    context: $("diab_gContext")?.value || "autre",
    time: $("diab_gTime")?.value || "",
    note: ($("diab_gNote")?.value || "").trim(),
    createdAt: new Date().toISOString()
  });

  const now = diab_getGlucoseForDay(dateStr);
  now.push(entry);
  diab_setGlucoseForDay(dateStr, now);

  if ($("diab_gValue")) $("diab_gValue").value = "";
  if ($("diab_gNote")) $("diab_gNote").value = "";
  if ($("diab_gTime")) $("diab_gTime").value = "";

  diab_renderGlucoseTable(dateStr);
  diab_renderDayKpis(dateStr);
  diab_renderDaysHistory();
}

function diab_clearGlucoseForDay(){
  const dateStr = getSelectedDate();
  diab_setGlucoseForDay(dateStr, []);
  diab_renderGlucoseTable(dateStr);
  diab_renderDayKpis(dateStr);
  diab_renderDaysHistory();
}

function diab_glucoseStats(itemsMgdl){
  const vals = itemsMgdl.filter(x => Number.isFinite(x) && x > 0);
  if (vals.length === 0) return null;
  const min = Math.min(...vals);
  const max = Math.max(...vals);
  const avg = vals.reduce((s,v)=>s+v,0) / vals.length;
  return { count: vals.length, min, max, avg };
}

function diab_renderDayKpis(dateStr){
  const box = $("diab_dayKpis");
  const note = $("diab_dayNote");
  if (!box || !note) return;

  // Source de vérité = repas V1 : eatenC (priorité) sinon tC
  const carbsDay = isFinite(toNum($("eatenC")?.value))
    ? toNum($("eatenC")?.value)
    : toNum($("tC")?.value);

  const carbs = Number.isFinite(carbsDay) ? carbsDay : 0;

  box.innerHTML = `<div class="card"><b>Glucides (g)</b>${round(carbs,1)}</div>`;
  note.textContent = "TOTAL des glucides des repas du jour encodés";
}

function diab_renderDaysHistory(targetId){
  const box = $(targetId || "diab_daysHistory");
  if (!box) return;

  const settings = diab_getSettings();
  const unit = $("diab_glucoseUnit")?.value || settings.glucoseUnit || "mgdl";

  const days = loadDays().sort((a,b)=> String(b.date).localeCompare(String(a.date)));

  // On garde seulement les jours qui ont AU MOINS une donnée diabète
  const filtered = days.filter(d =>
    (Array.isArray(d?.diabGlucose) && d.diabGlucose.length) ||
    (d?.diabMeta && Object.keys(d.diabMeta).length) ||
    (d?.diabSettings && Object.keys(d.diabSettings).length)
  );

  if (filtered.length === 0){
    box.innerHTML = "<p class='muted'>Aucune journée diabète enregistrée.</p>";
    return;
  }

  // Carry-forward HbA1c : on calcule en ASC, puis on affiche en DESC
  const asc = [...filtered].sort((a,b)=> String(a.date).localeCompare(String(b.date)));
  let lastA1c = null;
  let lastA1cDate = "";
  const a1cByDate = {};

  for (const d of asc){
    const meta = diab_normalizeMeta(d?.diabMeta || {});
    if (meta.hba1c != null){
      lastA1c = meta.hba1c;
      lastA1cDate = meta.hba1cDate || d.date;
    }
    a1cByDate[d.date] =
      (lastA1c != null)
        ? `${round(lastA1c,1)}%${lastA1cDate ? ` (${escapeHtml(lastA1cDate)})` : ""}`
        : "-";
  }

  box.innerHTML = `
    <div class="table-wrap">
      <table>
        <thead>
          <tr>
            <th>Date</th>
            <th>Glucides (g)</th>
            <th>Total glycémies (${unit==="mmol"?"mmol/L":"mg/dL"})</th>
            <th>HbA1c</th>
            <th>Maladie</th>
            <th>Alcool</th>
            <th>Stress</th>
            <th>Sommeil</th>
            <th style="text-align:left">Activité</th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody>
          ${filtered.map(d => {
            // Glucides du jour : on calcule depuis les repas V1 du jour (stockés par date)
            const meals = getMealsForDay(d.date);
            const t = mealsTotals(meals);
            const carbs = Number.isFinite(toNum(t?.c)) ? toNum(t.c) : 0;

            // Glycémies : somme des valeurs
            const gl = Array.isArray(d.diabGlucose) ? d.diabGlucose.map(diab_normalizeGlucose) : [];
            const sumMgdl = gl.reduce((s,x)=> s + (Number.isFinite(toNum(x.mgdl)) ? toNum(x.mgdl) : 0), 0);
            const totalGly = (gl.length === 0)
              ? "-"
              : (unit === "mmol" ? round(diab_mgdlToMmol(sumMgdl), 1) : round(sumMgdl, 0));

            const meta = diab_normalizeMeta(d?.diabMeta || {});
            const sickTxt = meta.sick ? (meta.sick==="yes"?"Oui":"Non") : "-";
            const alcTxt  = meta.alcohol ? (meta.alcohol==="yes"?"Oui":"Non") : "-";
            const stressTxt = (meta.stress == null) ? "-" : `${meta.stress}/10`;
            const sleepTxt  = (meta.sleepH == null) ? "-" : `${round(meta.sleepH,1)}h`;
            const actTxt    = meta.activity ? escapeHtml(meta.activity) : "-";

            return `
              <tr>
                <td>${escapeHtml(d.date)}</td>
                <td>${round(carbs,1)}</td>
                <td>${totalGly}</td>
                <td>${a1cByDate[d.date] || "-"}</td>
                <td>${sickTxt}</td>
                <td>${alcTxt}</td>
                <td>${stressTxt}</td>
                <td>${sleepTxt}</td>
                <td class="td-left">${actTxt}</td>
                <td>
                  <button class="btn-mini btn-danger"
                          data-action="diab-day-del"
                          data-date="${escapeHtml(d.date)}"
                          type="button">Suppr.</button>
                </td>
              </tr>
            `;
          }).join("")}
        </tbody>
      </table>
    </div>
  `;

  // ✅ Wire delete : supprime UNIQUEMENT l’historique diabète de la date (pas les repas)
  box.querySelectorAll("button[data-action='diab-day-del']").forEach(btn => {
    btn.addEventListener("click", () => {
      const dateStr = btn.getAttribute("data-date");
      if (!dateStr) return;
      if (!confirm(`Supprimer l’historique diabète de la journée ${dateStr} ?`)) return;
      diab_deleteDiabHistoryRow(dateStr);
    });
  });
}

function diab_renderAll(dateStr){
  // Settings from day if any
  const d = getDay(dateStr);
  const s = d?.diabSettings || null;
  if ($("diab_glucoseUnit") && s?.glucoseUnit) $("diab_glucoseUnit").value = s.glucoseUnit;
  if ($("diab_carbPortionG") && s?.carbPortionG) $("diab_carbPortionG").value = Math.max(5, toNum(s.carbPortionG));

  diab_loadMetaIntoUI(dateStr);
  diab_renderMealsTable(dateStr);
  diab_renderGlucoseTable(dateStr);
  diab_renderDayKpis(dateStr);
  diab_renderDaysHistory();
}

function initDiabModule(){
  // Si l'onglet diab n'existe pas dans cette version, on ne fait rien.
  if (!$("diab_glucoseUnit")) return;

  const dateStr = getSelectedDate();

  // boutons
  $("diab_btnAddMeal")?.addEventListener("click", () => diab_addMealFromInputs());
  $("diab_btnClearMeals")?.addEventListener("click", () => diab_clearMealsForDay());
  $("diab_btnApplyPer100")?.addEventListener("click", () => diab_applyPer100ToMeal());

  $("diab_btnAddGlucose")?.addEventListener("click", () => diab_addGlucoseFromInputs());
  $("diab_btnClearGlucose")?.addEventListener("click", () => diab_clearGlucoseForDay());

  // settings change => sauvegarde (dans la journée) + refresh
  ["diab_glucoseUnit"].forEach(id => {
    $(id)?.addEventListener("change", () => {
      const v = (id==="diab_carbPortionG") ? clamp(toNum($("diab_carbPortionG").value), 5, 60) : null;
      if (v != null) $("diab_carbPortionG").value = v;
      diab_saveSettings();
      diab_renderAll(getSelectedDate());
    });
  });

  // meta autosave
  ["diab_dayActivity","diab_dayStress","diab_daySleepH","diab_daySick","diab_dayAlcohol","diab_dayNoteFree","diab_hba1c","diab_hba1cDate"]
.forEach(id => {
    $(id)?.addEventListener("change", () => {
      const d = getSelectedDate();
      diab_saveMetaFromUI(d);
      diab_renderDayKpis(d);
      diab_renderDaysHistory();
    });
  });
$("diab_btnSaveDayMeta")?.addEventListener("click", () => {
  const d = getSelectedDate();
  diab_renderDayKpis(d);
  diab_renderDaysHistory();
});


  // synchro changements date/profil
  $("dayDate")?.addEventListener("change", () => diab_renderAll(getSelectedDate()));
  $("profileSelect")?.addEventListener("change", () => diab_renderAll(getSelectedDate()));

  diab_renderAll(dateStr);
}

initDiabModule();


/* =====================================================================
   10) Cloud sync (Supabase)
   UI piloté: #cloudStatus + boutons cloud
   ===================================================================== */
// Sync multi-support (Supabase)
// - Permet de retrouver tes données sur plusieurs appareils.
// - L'app reste utilisable en local si la synch est indisponible.
// ==============================
      const ENABLE_CLOUD_SYNC = true;

      const SUPABASE_URL = "https://ztrqqtjktydibcznbpen.supabase.co";
      const SUPABASE_ANON_KEY = "sb_publishable_VvPPkGiqqRBj1QSsdVboGg_uHzO06-o";

      let supa = null;
      if (window.supabase && SUPABASE_URL && SUPABASE_ANON_KEY) {
        if (ENABLE_CLOUD_SYNC) {
          supa = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
        } else {
          supa = null;
        }
      } 
      async function handleMagicLinkCallback() {
        if (!supa) return;

        const params = new URLSearchParams(window.location.search);
        const token_hash = params.get("token_hash");
        const type = params.get("type") || "email";
        if (!token_hash) return;

        setCloudStatus("Validation du lien en cours...");

        const { error } = await supa.auth.verifyOtp({ token_hash, type });
        if (error) {
          setCloudStatus("Lien invalide/expiré : " + error.message);
          return;
        }
       }

 /* =========================
         ✅ Cloud sync (pull/push)
         ========================= */
      function setCloudStatus(msg){
        const el = $("cloudStatus");
        if (el) el.textContent = "Statut : " + msg;
      }

      async function cloudGetUser(){
        if (!supa) return null;
        const { data, error } = await supa.auth.getUser();
        if (error) return null;
        return data?.user || null;
      }

      function buildLocalSnapshot(profileId){
        let settings = null;
        try { settings = JSON.parse(localStorage.getItem(settingsKeyFor(profileId)) || "null"); } catch {}
        let days = [];
        try { days = JSON.parse(localStorage.getItem(daysKeyFor(profileId)) || "[]"); } catch { days = []; }

        return {
          schemaVersion: 1,
          profileId,
          settings: settings || null,
          days: Array.isArray(days) ? days : [],
          updatedAt: new Date().toISOString()
        };
      }

      function writeSnapshotToLocal(snapshot){
        const profileId = snapshot?.profileId || getActiveProfile() || "default";
        if (snapshot?.settings) localStorage.setItem(settingsKeyFor(profileId), JSON.stringify(snapshot.settings));
        if (Array.isArray(snapshot?.days)) localStorage.setItem(daysKeyFor(profileId), JSON.stringify(snapshot.days));
      }

      function mergeSnapshots(localSnap, cloudSnap){
        if (!cloudSnap) return localSnap;
        if (!localSnap) return cloudSnap;

        const out = {
          schemaVersion: 1,
          profileId: localSnap.profileId || cloudSnap.profileId || "default",
          settings: null,
          days: [],
          updatedAt: new Date().toISOString()
        };

        const lS = localSnap.settings;
        const cS = cloudSnap.settings;
        const lAt = (lS && lS.updatedAt) ? String(lS.updatedAt) : "";
        const cAt = (cS && cS.updatedAt) ? String(cS.updatedAt) : "";
        out.settings = (cAt > lAt) ? cS : lS;

        const lDays = Array.isArray(localSnap.days) ? localSnap.days : [];
        const cDays = Array.isArray(cloudSnap.days) ? cloudSnap.days : [];

        const map = new Map();
        for (const d of lDays) if (d?.date) map.set(d.date, d);
        for (const d of cDays) {
          if (!d?.date) continue;
          const existing = map.get(d.date);
          if (!existing) { map.set(d.date, d); continue; }

          const eAt = String(existing.updatedAt || "");
          const dAt = String(d.updatedAt || "");
          const winner = (dAt > eAt) ? d : existing;
          const loser  = (dAt > eAt) ? existing : d;

          const wm = Array.isArray(winner.meals) ? winner.meals : [];
          const lm = Array.isArray(loser.meals) ? loser.meals : [];
          const mm = new Map();
          for (const m of lm) if (m?.id) mm.set(m.id, m);
          for (const m of wm) if (m?.id) mm.set(m.id, m);
          const mergedMeals = Array.from(mm.values()).sort((a,b)=> String(a.createdAt||"").localeCompare(String(b.createdAt||"")));

          map.set(d.date, { ...winner, meals: mergedMeals, updatedAt: winner.updatedAt || new Date().toISOString() });
        }

        out.days = Array.from(map.values()).sort((a,b)=> String(a.date).localeCompare(String(b.date)));
        return out;
      }

      async function cloudPull(){
        if (!supa) { setCloudStatus("Sync inactive (Supabase non configuré)."); return; }
        const user = await cloudGetUser();
        if (!user) { setCloudStatus("Non connecté."); return; }

        const profileId = getActiveProfile() || "default";

        const { data, error } = await supa
          .from("cloud_profiles")
          .select("payload, updated_at")
          .eq("user_id", user.id)
          .eq("profile_id", profileId)
          .maybeSingle();

        if (error) { setCloudStatus("Erreur pull : " + error.message); return; }
        if (!data?.payload) { setCloudStatus("Aucune sauvegarde cloud pour ce profil."); return; }

        const localSnap = buildLocalSnapshot(profileId);
        const cloudSnap = data.payload;
        const merged = mergeSnapshots(localSnap, cloudSnap);

        writeSnapshotToLocal(merged);

        loadProfileSettings();
  lockMacroControls($("dietMode").value === "custom");
  updateCarbGuardExplain();
  updateFatFloorUI();
        refreshDaySelect();
        renderDaysHistory();
        renderMealsTable(getSelectedDate());
        updateBodyCompUI(getSelectedDate());
        compute(true);

        setCloudStatus("Pull OK (cloud → local).");
      }

      async function cloudPush(){
        if (!supa) { setCloudStatus("Sync inactive (Supabase non configuré)."); return; }
        const user = await cloudGetUser();
        if (!user) { setCloudStatus("Non connecté."); return; }

        const profileId = getActiveProfile() || "default";
        const localSnap = buildLocalSnapshot(profileId);

        const row = {
          user_id: user.id,
          profile_id: profileId,
          payload: localSnap,
          updated_at: new Date().toISOString()
        };

        const { error } = await supa
          .from("cloud_profiles")
          .upsert(row, { onConflict: "user_id,profile_id" });

        if (error) { setCloudStatus("Erreur push : " + error.message); return; }

        setCloudStatus("Push OK (local → cloud).");
      }

      async function cloudSync(){
        if (!supa) { setCloudStatus("Sync inactive (Supabase non configuré)."); return; }
        const user = await cloudGetUser();
        if (!user) { setCloudStatus("Non connecté."); return; }

        const profileId = getActiveProfile() || "default";

        const { data, error } = await supa
          .from("cloud_profiles")
          .select("payload")
          .eq("user_id", user.id)
          .eq("profile_id", profileId)
          .maybeSingle();

        if (error) { setCloudStatus("Erreur pull : " + error.message); return; }

        const localSnap = buildLocalSnapshot(profileId);
        const cloudSnap = data?.payload || null;

        const merged = mergeSnapshots(localSnap, cloudSnap);

        writeSnapshotToLocal(merged);

        const row = {
          user_id: user.id,
          profile_id: profileId,
          payload: merged,
          updated_at: new Date().toISOString()
        };

        const { error: pushErr } = await supa
          .from("cloud_profiles")
          .upsert(row, { onConflict: "user_id,profile_id" });

        if (pushErr) { setCloudStatus("Merge OK mais push KO : " + pushErr.message); return; }

        loadProfileSettings();
  lockMacroControls($("dietMode").value === "custom");
  updateCarbGuardExplain();
  updateFatFloorUI();
        refreshDaySelect();
        renderDaysHistory();
        renderMealsTable(getSelectedDate());
        updateBodyCompUI(getSelectedDate());
        compute(true);

        setCloudStatus("Sync OK (Pull → Merge → Push).");
      }

    async function cloudLoginWithEmail(email){
  if (!supa) { setCloudStatus("Sync inactive (Supabase non configuré)."); return; }

  const e = String(email || "").trim();
  if (!e) { setCloudStatus("Entre un email."); return; }

  // 1) Cas critique : app ouverte en file:// (tu l’as dans tes logs)
  if (location.protocol === "file:") {
    setCloudStatus("Erreur login : l'app est ouverte en file://. Lance-la via http://localhost (serveur local) pour activer la synchro.");
    return;
  }

  // 2) Redirect stable (évite file:// + évite query/hash)
  const redirectTo = location.origin + location.pathname;

  try {
    const { data, error } = await supa.auth.signInWithOtp({
      email: e,
      options: { emailRedirectTo: redirectTo }
    });

    if (error) {
      setCloudStatus("Erreur login : " + (error.message || "inconnue"));
      return;
    }

    setCloudStatus("Lien envoyé. Ouvre tes emails et clique le lien.");
  } catch (err) {
    // 3) Ici tu captures le vrai problème "Failed to fetch" (DNS / réseau / extension / CORS)
    const msg = String(err?.message || err || "");
    if (/Failed to fetch/i.test(msg)) {
      setCloudStatus("Erreur login : Failed to fetch (réseau/DNS/CORS/extension). Vérifie la console (net::ERR_NAME_NOT_RESOLVED).");
    } else {
      setCloudStatus("Erreur login : " + msg);
    }
  }
}

async function cloudLogout(){
  if (!supa) { setCloudStatus("Sync inactive (Supabase non configuré)."); return; }
  try {
    await supa.auth.signOut();
    setCloudStatus("Déconnecté (local uniquement).");
  } catch (err) {
    setCloudStatus("Erreur logout : " + String(err?.message || err || ""));
  }
}


/* createClient */ 

/* =====================================================================
   11) Modal “info montre”
   UI piloté: #watchProfileInfo, #watchInfoModal, #watchInfoBody, boutons close/ok
   ===================================================================== */
function isSportOrExpert(){
  const m = document.body.getAttribute("data-usemode");
  return (m === "sport" || m === "expert");
}
function openWatchInfoModal(text){
  const modal = $("watchInfoModal");
  const body  = $("watchInfoBody");
  if (!modal || !body) return;
  body.textContent = text || "Aucune information.";
  modal.classList.add("is-open");
  modal.setAttribute("aria-hidden", "false");
}
function closeWatchInfoModal(){
  const modal = $("watchInfoModal");
  if (!modal) return;
  modal.classList.remove("is-open");
  modal.setAttribute("aria-hidden", "true");
}

/* =====================================================================
   12) Compute (moteur)
   UI piloté: quasi tout (sorties tK/tP/tC/tF, notes, etc.)
   ===================================================================== */
/* ============================================================
   Carb repères : panneau explicatif (UI)
   - "Glucides calculés" = valeur avant plafonds
   - "Plafond pris en compte" = cap effectif (si contraignant ou non)
   ============================================================ */
function updateCarbCalcPanel(ctx){
  const rawEl = $("carbCalcRawG");
  const capEl = $("carbCalcCapG");
  const capKgEl = $("carbCalcCapKg");
  const srcEl = $("carbCalcCapSrc");
  const stEl  = $("carbCalcStatus");
  if (!rawEl || !capEl || !stEl) return;

  const w = Math.max(0, toNum($("weight")?.value));
  const goalRaw = $("carbGoal")?.value || "none";
  const goalKey = (typeof normCarbGoalKey === "function") ? normCarbGoalKey(goalRaw) : goalRaw;

  // Ranges "objectif" (g/kg/j) : sert à contextualiser le plafond choisi (cap g/kg)
  const GOAL_RANGES = {
    strict:   { min: 2.0,  max: 3.0,  label: "Sèche stricte" },
    sport:    { min: 3.0,  max: 4.0,  label: "Sèche sportive" },
    recomp:   { min: 4.0,  max: 5.0,  label: "Recomposition" },
    maintain: { min: 4.0,  max: 6.0,  label: "Maintien actif" },
    volume:   { min: 6.0,  max: 8.0,  label: "Endurance / volume" },
    endurance:{ min: 6.0,  max: 8.0,  label: "Endurance / volume" }, // compat ancienne clé
    carbload: { min: 8.0,  max: 12.0, label: "Carb-loading" }
  };
  const gr = GOAL_RANGES[goalKey] || null;

  const targetCraw = ctx?.targetCraw;
  const targetC    = ctx?.targetC;
  const lowCarbEnabled    = !!ctx?.lowCarbEnabled;
  const lowCarbImpossible = !!ctx?.lowCarbImpossible;

  rawEl.textContent = (Number.isFinite(targetCraw) ? String(round(targetCraw, 1)) : "—");

  // Low-carb : on sort volontairement du modèle "plafond"
  if (lowCarbEnabled){
    capEl.textContent = (Number.isFinite(targetC) ? String(round(targetC, 1)) : "—");
    if (capKgEl){
      const kg = (w > 0 && Number.isFinite(targetC)) ? (targetC / w) : NaN;
      capKgEl.textContent = (w > 0 && Number.isFinite(kg)) ? ` (${round(kg, 2)} g/kg)` : "";
    }
    if (srcEl) srcEl.textContent = " (low-carb)";
    stEl.textContent = lowCarbImpossible
      ? "Low-carb impossible à cette cible : lipides au plancher, glucides remontés pour respecter les calories."
      : "Low-carb : glucides fixés, les lipides s’ajustent pour tenir la cible kcal.";
    return;
  }

  const carbCapG = ctx?.carbCapG;                 // cap effectif final en g/j
  const capFromGkg   = ctx?.capFromGkg;           // g/j (si repères ON et cap g/kg)
  const capFromRatio = ctx?.capFromRatio;         // g/j (si ratio actif)
  const carbCapGPerKgApplied = ctx?.carbCapGPerKgApplied || 0; // g/kg/j réellement pris en compte
  const ratioCPApplied       = ctx?.ratioCPApplied || 0;       // ratio réellement pris en compte

  // Pas de plafond actif => aucune limitation : glucides = calories restantes (après P+F)
  if (!(Number.isFinite(carbCapG) && carbCapG > 0)){
    capEl.textContent = "—";
    if (capKgEl) capKgEl.textContent = "";
    if (srcEl) srcEl.textContent = "";
    // Contexte : si un objectif est sélectionné mais repères OFF, on le rappelle
    const goalLine = (gr && w > 0 && Number.isFinite(toNum($("carbCapGPerKg")?.value)))
      ? `Objectif ${gr.label} : ${gr.min.toFixed(1)}–${gr.max.toFixed(1)} g/kg/j (plafond non appliqué si repères OFF).`
      : "";
    stEl.textContent =
      "Aucun plafond actif : les glucides sont déterminés par les calories restantes après protéines et lipides."
      + (goalLine ? "\n" + goalLine : "");
    return;
  }

  capEl.textContent = String(round(carbCapG, 1));
  if (capKgEl){
    const kg = (w > 0 && Number.isFinite(carbCapG)) ? (carbCapG / w) : NaN;
    capKgEl.textContent = (w > 0 && Number.isFinite(kg)) ? ` (${round(kg, 2)} g/kg)` : "";
  }

  // Source(s) du cap effectif (g/kg et/ou ratio). On affiche ceux qui « mordent » réellement.
  const srcs = [];
  const eps = 0.06; // tolérance d'arrondi (g)
  if (Number.isFinite(capFromGkg) && Math.abs(carbCapG - capFromGkg) <= eps && carbCapGPerKgApplied > 0){
    srcs.push(`${round(carbCapGPerKgApplied, 1)} g/kg`);
  }
  if (Number.isFinite(capFromRatio) && Math.abs(carbCapG - capFromRatio) <= eps && ratioCPApplied > 0){
    srcs.push(`ratio ${round(ratioCPApplied, 2)}`);
  }
  if (srcEl) srcEl.textContent = srcs.length ? ` (${srcs.join(" ; ")})` : "";

  // Statut : le plafond ne fait baisser les glucides que s'il est < aux glucides "bruts"
  const isBinding = (Number.isFinite(targetCraw) && targetCraw > (carbCapG + eps));
  const bindLine = isBinding
    ? "Plafond actif : les glucides sont limités (les calories restantes basculent vers les lipides)."
    : "Plafond non contraignant : tes glucides calculés sont déjà sous le plafond (rien à limiter).";

  // Contexte objectif : où se situe ton plafond g/kg dans la plage de l’objectif
  let goalLine = "";
  if (gr && w > 0){
    const capKgNow = (carbCapGPerKgApplied > 0) ? carbCapGPerKgApplied : toNum($("carbCapGPerKg")?.value);
    if (Number.isFinite(capKgNow) && capKgNow > 0){
      const capGNow = capKgNow * w;
      goalLine =
        `Objectif ${gr.label} : ${gr.min.toFixed(1)}–${gr.max.toFixed(1)} g/kg/j. ` +
        `Plafond choisi : ${round(capKgNow, 1)} g/kg (≈ ${Math.round(capGNow)} g/j).`;
    } else {
      goalLine = `Objectif ${gr.label} : ${gr.min.toFixed(1)}–${gr.max.toFixed(1)} g/kg/j.`;
    }
  }

  const capKgTaken = (w > 0 && Number.isFinite(carbCapG)) ? (carbCapG / w) : NaN;
  const capTakenLine = (w > 0 && Number.isFinite(capKgTaken))
    ? `Plafond pris en compte : ${round(capKgTaken, 2)} g/kg/j (≈ ${round(carbCapG, 1)} g/j).`
    : "";

  stEl.textContent = bindLine
    + (capTakenLine ? "\n" + capTakenLine : "")
    + (goalLine ? "\n" + goalLine : "");
}


function compute(saveToJournal = true, scrollToResults = false) {
  // ============================================================
  // 0) Lecture inputs (DOM -> variables)
  // ============================================================
  const sex = $("sex").value;
  const age = toNum($("age").value);
  const h   = toNum($("height").value);
  const w   = toNum($("weight").value);

  const montre  = toNum($("montre").value);
  const errPct  = Math.max(0, toNum($("errPct")?.value));
  const errMode = $("errMode")?.value || "conservative";

  const dietMode = $("dietMode")?.value || "cut_standard";

  const goalPctRaw = toNum($("goalPct")?.value);
  const goalPct    = clamp(goalPctRaw, 60, 130);
  if ($("goalPct") && goalPct !== goalPctRaw) $("goalPct").value = goalPct;

  const protPerKg = Math.max(0, toNum($("protPerKg")?.value));
  const fatPerKg  = Math.max(0, toNum($("fatPerKg")?.value));
  const fatFloorChosen = Math.max(0, toNum($("fatFloorGPerKg")?.value));

  // Modes optionnels
  const carbGuardEnabled = !!$("carbGuardEnabled")?.checked;
  const lowCarbEnabled   = !!$("lowCarbEnabled")?.checked;

  const carbGoalKey = ($("carbGoal")?.value) || "off";

  // ============================================================
  // 1) Détermination lipides effectifs (planchers)
  // ============================================================
  const fatFloor  = fatFloorForGoal(carbGoalKey); // objet {min,max,...}
  const floorMeta = fatFloorForGoal(carbGoalKey); // min théorique selon objectif (peut valoir 0 si "off")

  let fatPerKgEff = fatPerKg;

  if (dietMode !== "custom") {
    // 1) plancher choisi (UI) : doit impacter le socle même si Repères glucidiques OFF
    if (fatFloorChosen > 0) fatPerKgEff = Math.max(fatPerKgEff, fatFloorChosen);

    // 2) sécurité : si un objectif impose un min (et que l’UI n’a pas/peu rempli), on ne descend jamais sous ce min
    if (floorMeta?.min > 0) fatPerKgEff = Math.max(fatPerKgEff, floorMeta.min);
  }

  // UI : box "lipides effectifs"
  const effBox = $("fatPerKgEffBox");
  const effTxt = $("fatPerKgEffTxt");

  if (effBox && effTxt) {
    const isConstraining =
      (carbGuardEnabled || lowCarbEnabled) &&
      (fatPerKgEff > fatPerKg + 1e-9);

    if (isConstraining) {
      effTxt.textContent = round(fatPerKgEff, 2);
      effBox.style.display = "block";
    } else {
      effBox.style.display = "none";
    }
  }

  // ============================================================
  // 2) Contexte jour + ingestion (repas)
  // ============================================================
  const dateForDay = getSelectedDate();
  $("dayDate").value = dateForDay;

  const eaten = syncEatenFromMeals(dateForDay);
  const eatenK = eaten.k, eatenP = eaten.p, eatenC = eaten.c, eatenF = eaten.f;

  // ============================================================
  // 3) Ajustement montre + cible kcal
  // ============================================================
  const errFactor = errPct / 100;

  let montreAdjusted = montre;
  if (errMode === "conservative") montreAdjusted = montre * (1 - errFactor);
  if (errMode === "optimistic")   montreAdjusted = montre * (1 + errFactor);

  const targetKcal = montreAdjusted * (goalPct / 100);

  // ============================================================
  // 4) Cibles P/F/C (base) + modes glucides
  // ============================================================
  const targetP = protPerKg * w;

  // Lipides "plancher" (base)
  const targetFbase = fatPerKgEff * w;

  // Calories disponibles après P+Fbase
  const kcalFromPFbase   = (targetP * 4) + (targetFbase * 9);
  const kcalLeftForCbase = targetKcal - kcalFromPFbase;

  // Glucides bruts (sans Repères glucidiques)
  const targetCraw = kcalLeftForCbase / 4;

  // ---------- Modes glucides ----------
  let targetC = targetCraw;
  let targetF = targetFbase;

  // Variables de contexte (pour note/UI)
  let carbCapGPerKg = 0;     // g/kg/j
  let ratioCP = 0;           // ratio G/P max
  let carbCapGPerKgApplied = 0; // g/kg/j effectivement pris en compte (repères ON)
  let ratioCPApplied = 0;       // ratio effectivement pris en compte (libre ou objectif)
  let capFromGkg = null;        // cap issu g/kg (g/j)
  let capFromRatio = null;      // cap issu ratio (g/j)
  let carbCapG = null;       // cap glucides final en g (après min)
  let kcalRemaining = 0;     // kcal déplacées vers lipides (carb-guard)
  let lowCarbKg = 0;         // g/kg/j (low-carb)
  let lowCarbImpossible = false;

  // (1) Low-carb explicite : C fixé bas, F ajuste (carb-goals désactivé)
  if (lowCarbEnabled) {
    lowCarbKg = Math.max(0, toNum($("lowCarbStep")?.value)); // g/kg/j
    const targetClc = lowCarbKg * w;

    // Fat requis pour atteindre la cible kcal avec P et C fixés
    const fatNeeded = (targetKcal - (targetP * 4) - (targetClc * 4)) / 9;

    targetC = Math.max(0, targetClc);

    // Plancher : lipides preset sert ici de minimum de sécurité
    const fatMin = targetFbase;

    if (!Number.isFinite(fatNeeded)) {
      targetF = fatMin;
    } else if (fatNeeded >= fatMin) {
      targetF = fatNeeded;
    } else {
      // Impossible de tenir "low-carb" à cette cible kcal sans descendre sous les planchers :
      // on maintient le plancher lipides, et on remplit le reste en glucides (warning via note).
      lowCarbImpossible = true;
      targetF = fatMin;
      targetC = Math.max(0, (targetKcal - (targetP * 4) - (targetF * 9)) / 4);
    }

  // (2) Carb-guard optionnel : plafonds glucides (si activé)
  } else {
    carbCapGPerKg = Math.max(0, toNum($("carbCapGPerKg").value));  // 0 = off
    ratioCP       = Math.max(0, toNum($("ratioCP").value));        // 0 = off

    const ratioCPApplied       = (!lowCarbEnabled && ratioCP > 0) ? ratioCP : 0; // ratio libre ou objectif (si repères ON), ignoré en low-carb
        carbCapGPerKgApplied = carbGuardEnabled ? carbCapGPerKg : 0; // g/kg seulement quand repères ON

    if (carbCapGPerKgApplied > 0) capFromGkg = carbCapGPerKgApplied * w;

    if (ratioCPApplied > 0) capFromRatio = ratioCPApplied * targetP; // g glucides max = ratio * protéines

    for (const v of [capFromGkg, capFromRatio]) {
      if (v != null && Number.isFinite(v) && v >= 0) {
        carbCapG = (carbCapG == null) ? v : Math.min(carbCapG, v);
      }
    }

    // Glucides après plafond(s)
    targetC = targetCraw;
    if (carbCapG != null) targetC = Math.min(targetCraw, carbCapG);
    targetC = Math.max(0, targetC);

    // Si on plafonne les glucides, on bascule les calories restantes en lipides (pour garder la cible kcal)
    const kcalUsedWithCap = (targetP * 4) + (targetC * 4) + (targetFbase * 9);
    targetF = targetFbase;

    kcalRemaining = targetKcal - kcalUsedWithCap;
    if (kcalRemaining > 0) targetF = targetFbase + (kcalRemaining / 9);
  }


// ---- UI : repères glucidiques (pédagogie)
updateCarbCalcPanel({
  targetCraw,
  targetC,
  lowCarbEnabled,
  lowCarbKg,
  lowCarbImpossible,
  carbCapG,
  capFromGkg,
  capFromRatio,
  carbCapGPerKgApplied,
  ratioCPApplied
});

  // ============================================================
  // 5) Restes (cibles - consommé)
  // ============================================================
  const remK = targetKcal - eatenK;
  const remP = targetP - eatenP;
  const remC = targetC - eatenC;
  const remF = targetF - eatenF;

  const remKShow = Math.max(0, remK);
  const remPShow = Math.max(0, remP);
  const remCShow = Math.max(0, remC);
  const remFShow = Math.max(0, remF);

  // ============================================================
  // 6) BMR + UI annexe
  // ============================================================
  const bmr = mifflinStJeor(sex, w, h, age);
  updateBodyCompUI(dateForDay);

  // ============================================================
  // 7) Affichage sortie + KPI groups
  // ============================================================
  if ($("out")) {
    $("out").classList.remove("hidden");
    $("out").style.display = "block";
    if (scrollToResults) $("out").scrollIntoView({ behavior: "smooth", block: "start" });
  }

  const kpis = $("kpis");
  if (kpis) {
    kpis.innerHTML = "";

    const mk = (title, value, cls = "") => {
      const d = document.createElement("div");
      if (cls) d.className = cls;
      d.innerHTML = `<b>${title}</b>${value}`;
      return d;
    };

    // Groupe 1 : Régime + Objectif
    const groupDiet = document.createElement("div");
    groupDiet.className = "kpis-group kpis-group-diet";
    groupDiet.appendChild(mk("Régime", makeDietBadge(dietMode, goalPct)));
    groupDiet.appendChild(mk("Objectif (%)", round(goalPct, 0) + "%"));
    kpis.appendChild(groupDiet);

    // Groupe 2 : Dépenses & cible kcal
    const groupEnergy = document.createElement("div");
    groupEnergy.className = "kpis-group kpis-group-energy";
    groupEnergy.appendChild(mk("Dépense montre (kcal)", round(montre, 0)));
    groupEnergy.appendChild(mk("Dépense ajustée (kcal)", round(montreAdjusted, 0), "warn"));
    groupEnergy.appendChild(mk("Cible du jour (kcal)", round(targetKcal, 0), "ok"));
    kpis.appendChild(groupEnergy);

// Groupe 3 : BMR (2 bulles, pleine largeur)
const groupBmr = document.createElement("div");
groupBmr.className = "kpis-group";
groupBmr.setAttribute("data-um", "expert");

// ✅ Force ce groupe à occuper toute la ligne du conteneur .kpi (flex-wrap)
groupBmr.style.flex = "1 1 100%";
groupBmr.style.width = "100%";

const bmrText =
`Pourquoi ?
Le BMR (métabolisme de base) = l’énergie minimale au repos (organes, respiration, température…).

Comment l’utiliser ?
• Ce n’est PAS ta dépense du jour.
• Ta dépense réelle = BMR + activité + digestion.
• Ici, c’est un repère : si ton objectif kcal est trop bas vs ton quotidien → fatigue/perf en baisse.

Exemple
BMR ≈ ${round(bmr,0)} kcal : même une journée “calme” dépasse souvent ce chiffre.`;

const deltaBmr = round(targetKcal - bmr, 0);
const deltaSign = deltaBmr > 0 ? "+" : "";
const deltaText =
`Lecture
Cible du jour − BMR.

Interprétation
• Si c’est très bas / négatif : ta cible est proche (ou sous) ton métabolisme de base → prudence.
• Si c’est positif : ta cible laisse une marge au-dessus du BMR (activité, digestion, etc.).

Valeur
${round(targetKcal,0)} − ${round(bmr,0)} = ${deltaSign}${deltaBmr} kcal`;

// 1) BMR
groupBmr.appendChild(
  mk(
    "BMR estimé (kcal)",
    `${round(bmr,0)} <span class="info-dot" role="button" tabindex="0" data-modaltext="${escapeHtml(bmrText)}">ℹ️</span>`
  )
);

// 2) Écart cible - BMR
groupBmr.appendChild(
  mk(
    "Écart cible − BMR (kcal)",
    `${deltaSign}${deltaBmr} <span class="info-dot" role="button" tabindex="0" data-modaltext="${escapeHtml(deltaText)}">ℹ️</span>`
  )
);

kpis.appendChild(groupBmr);
}

  // ============================================================
  // 8) Remplissage tableaux Résultats (targets / eaten / remaining)
  // ============================================================
  if ($("tK")) $("tK").textContent = round(targetKcal, 0);
  if ($("tP")) $("tP").textContent = round(targetP, 1);
  if ($("tC")) $("tC").textContent = round(targetC, 1);

  // UI : "Glucides : calcul auto" = affichage de la cible calculée (sans modifier le calcul)
  if ($("carbAutoHint")) {
    const wNow = Math.max(0, toNum($("weight")?.value));
    const gkg  = (wNow > 0) ? (targetC / wNow) : 0;
    $("carbAutoHint").value = `${round(targetC, 1)} g/j (≈ ${round(gkg, 2)} g/kg)`;
  }

  if ($("dietMode")?.value === "none") {
    // laisse le hint en mode neutre
    if ($("carbAutoHint")) $("carbAutoHint").value = "0";
    if ($("goalPct")) $("goalPct").value = "0";
    return; // IMPORTANT : stoppe l’UI qui écrase
  }

  if ($("tF")) $("tF").textContent = round(targetF, 1);

  if ($("eK"))  $("eK").textContent  = round(eatenK, 0);
  if ($("eP2")) $("eP2").textContent = round(eatenP, 1);
  if ($("eC2")) $("eC2").textContent = round(eatenC, 1);
  if ($("eF2")) $("eF2").textContent = round(eatenF, 1);

  if ($("rK")) $("rK").textContent = round(remKShow, 0);
  if ($("rP")) $("rP").textContent = round(remPShow, 1);
  if ($("rC")) $("rC").textContent = round(remCShow, 1);
  if ($("rF")) $("rF").textContent = round(remFShow, 1);

  // ============================================================
  // 9) Note (texte explicatif) + panneau pédagogique
  // ============================================================
  let note = `Valeurs indicatives pour le reste de la journée. Il n’est pas nécessaire d’atteindre chaque chiffre exactement.`;

  if (dietMode !== "custom" && fatFloor.min > 0) note += ` Plancher lipides: ${fatFloor.min} g/kg/j.`;

  if (kcalLeftForCbase < 0) {
    note += " ⚠️ Protéines + lipides (plancher) dépassent déjà les calories cibles : le plan est incohérent (baisse P/F ou hausse kcal).";
  } else {
    // Modes
    if (lowCarbEnabled) {
      note += ` Mode low-carb: ${round(lowCarbKg, 2)} g/kg/j.`;
      if (lowCarbImpossible) note += " ⚠️ Low-carb incompatible avec cette cible kcal + tes planchers (on a dû remonter les glucides pour atteindre la cible kcal).";
    } else if (!carbGuardEnabled) {
      note += " Repères glucidiques: désactivés.";
    }

    // Repères glucidiques
    const caps = [];
    if (carbCapGPerKg > 0) caps.push(`${round(carbCapGPerKg, 1)} g/kg/j`);
    if (ratioCP > 0)      caps.push(`ratio G/P ≤ ${round(ratioCP, 2)}`);

    if (caps.length > 0) {
      note += ` Plafond glucides actif (${caps.join(" ; ")}).`;
      if (targetCraw > targetC + 0.01) {
        note += ` Glucides bruts ${round(targetCraw, 1)} g → plafonnés à ${round(targetC, 1)} g.`;
        note += " Les calories restantes ont été basculées vers les lipides pour garder la cible kcal.";
      }
    }
  }

  $("notes").textContent = note;

  // PATCH v17.1 — dietNote = résumé dynamique des options choisies
  const dn = $("dietNote");
  if (dn) {
    const parts = [];
    parts.push(`Objectif ${Math.round(goalPct)}%`);
    parts.push(`Prot ${round(protPerKg, 1)} g/kg`);
    parts.push(`Lip ${round(fatPerKgEff, 2)} g/kg`);
    const rcp = toNum($("ratioCP")?.value || 0);
    if (rcp > 0) parts.push(`Ratio C/P ≤ ${round(rcp, 2)}`);
    parts.push(carbGuardEnabled ? "Repères glucidiques ON" : "Repères glucidiques OFF");
    if (lowCarbEnabled) parts.push(`Low-carb ON (${round(lowCarbKg, 2)} g/kg)`);
    else parts.push("Low-carb OFF");
    dn.textContent = parts.join(" · ");
  }

  // Panneau pédagogique : décomposition des calories (pure UI)
  updateCalorieFlowViz({
    targetKcal,
    montreAdjusted,
    goalPct,
    w,
    protPerKg,
    fatPerKgEff,
    targetP,
    targetC,
    targetF,
    targetFbase,
    targetCraw,
    carbGuardEnabled,
    carbCapG,
    kcalRemaining,
    lowCarbEnabled,
    lowCarbKg,
    lowCarbLevel: ($("lowCarbLevel")?.value || ""),
    lowCarbImpossible
  });

  // ============================================================
  // 10) Sauvegarde journal + settings (si demandé)
  // ============================================================
  if (saveToJournal) {
    const existing = getDay(dateForDay) || { date: dateForDay };
    const meals    = getMealsForDay(dateForDay);

    const dayObj = {
      ...existing,
      date: dateForDay,

      watchBrand: $("watchBrand").value,
      montreRaw: montre,
      montreAdjusted,
      errPct,
      errMode,

      dietMode: dietMode,
      goalPct,

      protPerKg,
      fatPerKgEff,

      meals,
      eaten: { k: eatenK, p: eatenP, c: eatenC, f: eatenF },

      targetKcal, targetP, targetC, targetF, targetCraw,

      carbGoal: $("carbGoal")?.value || "sport",
      carbCapGPerKg,
      ratioCP,
      remaining: { k: remK, p: remP, c: remC, f: remF },

      morningWeight: (toNum($("morningWeight")?.value) > 0) ? toNum($("morningWeight").value) : (existing.morningWeight ?? null),
      fatPct: (toNum($("fatPct")?.value) > 0) ? toNum($("fatPct").value) : (existing.fatPct ?? null),
      musclePct: (toNum($("musclePct")?.value) > 0) ? toNum($("musclePct").value) : (existing.musclePct ?? null),
      boneKg: (toNum($("boneKg")?.value) > 0) ? toNum($("boneKg").value) : (existing.boneKg ?? null),

      bmr,
      updatedAt: new Date().toISOString()
    };

    upsertDay(dayObj);
    saveProfileSettings();
  }

  // ============================================================
  // 11) Post-actions UI + diab module (si présent)
  // ============================================================
  applyUseMode($("useMode")?.value || "simple");

  try {
    if (typeof diab_updateQuickKpis === "function") diab_updateQuickKpis(getSelectedDate());
  } catch (e) {}
}


/* =====================================================================
   13) Wire Events (TOUT AU MÊME ENDROIT)
   Ici tu vois immédiatement : (UI id) -> (fonction)
   ===================================================================== */
function wireEvents(){
  // CGU
  $("ackTerms")?.addEventListener("change", () => {
    const ok = $("ackTerms").checked;
    setTermsAccepted(ok);
    setAppLocked(!ok);
    if (ok) setActiveTab("dash");
  });



  $("profileSelect")?.addEventListener("change", (e) => {
    setActiveProfile(e.target.value);
    loadProfileSettings();

    const accepted = isTermsAccepted();
    if ($("ackTerms")) $("ackTerms").checked = accepted;
    setAppLocked(!accepted);

    lockMacroControls($("dietMode").value === "custom");
    updateCarbGuardExplain();
    updateFatFloorUI();

    $("dayDate").value = isoToday();
    refreshDaySelect();
    renderDaysHistory();
    renderMealsTable(getSelectedDate());
    updateBodyCompUI(getSelectedDate());
    compute(true);
  });

  // Montre
  $("watchBrand")?.addEventListener("change", () => {
    applyBrandPreset($("watchBrand").value, true);
    saveProfileSettings();
    compute(true);
  });

  // Régime
  $("dietMode")?.addEventListener("change", () => {
    const mode = $("dietMode").value;
    lockMacroControls(mode === "custom");

    if (mode === "none" || mode === ""){
      setDietNoneUI();
      saveProfileSettings();
      compute(true);
      return;
    }

    if (mode !== "custom") applyDietPreset(mode);
    else {
      if ($("goalPct")) $("goalPct").value = "60";
      setDietNote("custom");
    }

    setProtRangeUI(mode, true);

    if ($("carbGoal")) {
      updateCarbGoalOptions(false, true); // pas de présélection
      updateCarbSteps();
      lockCarbControls();
      syncCarbGuardsFromUI();
      updateFatFloorUI();
    }

    setDietNote("none");
    saveProfileSettings();
    compute(true);
  });

  // Repères glucidiques
  $("carbGoal")?.addEventListener("change", () => {
    updateCarbGoalOptions(true);
    updateCarbSteps();
    lockCarbControls();
    syncCarbGuardsFromUI();
    saveProfileSettings();
    compute(true);
  });

  $("carbStep")?.addEventListener("change", () => {
    $("carbCapGPerKg").value = toNum($("carbStep").value) || 0;
    syncCarbGuardsFromUI();
    saveProfileSettings();
    compute(true);
  });

  $("carbCapGPerKg")?.addEventListener("input", () => { syncCarbGuardsFromUI(); compute(true); });
  $("carbCapGPerKg")?.addEventListener("change", () => { syncCarbGuardsFromUI(); saveProfileSettings(); compute(true); });

  $("fatFloorGPerKg")?.addEventListener("input", () => { updateFatFloorUI(); saveProfileSettings(); compute(true); });
  $("fatFloorGPerKg")?.addEventListener("change", () => { updateFatFloorUI(); saveProfileSettings(); compute(true); });

  // Mode d’usage
  $("useMode")?.addEventListener("change", () => {
    applyUseMode($("useMode").value);
    saveProfileSettings();
    compute(true);
  });

  // Diabète
  $("diabEnabled")?.addEventListener("change", () => {
    applyDiabMode($("diabEnabled").checked);
    saveProfileSettings();
    diab_updateQuickKpis(getSelectedDate());
  });

window.addEventListener("diab:carbs-pushed", (e) => {
  const d = e?.detail?.date || (getSelectedDate?.() || "");
  if (typeof diab_renderDayKpis === "function") diab_renderDayKpis(d);
});


  // Modal montre
  $("watchProfileInfo")?.addEventListener("keydown", (e) => {
    if (!isSportOrExpert()) return;
    if (e.key !== "Enter" && e.key !== " ") return;
    e.preventDefault();
    openWatchInfoModal(e.currentTarget.getAttribute("data-modaltext") || "");
  });
  $("watchProfileInfo")?.addEventListener("click", () => {
    if (!isSportOrExpert()) return;
    openWatchInfoModal($("watchProfileInfo").getAttribute("data-modaltext") || "");
  });
  document.addEventListener("keydown", (e) => { if (e.key === "Escape") closeWatchInfoModal(); });
  $("watchInfoClose")?.addEventListener("click", closeWatchInfoModal);
  $("watchInfoOk")?.addEventListener("click", closeWatchInfoModal);
  document.querySelector("#watchInfoModal .modal__backdrop")?.addEventListener("click", closeWatchInfoModal);

  // Preset edit -> custom
  ["goalPct","fatPerKg"].forEach(id => {
    $(id)?.addEventListener("change", () => {
      forceCustomIfPresetEdited();
      saveProfileSettings();
      compute(true);
    });
  });

  $("protPerKg")?.addEventListener("change", () => {
    const dm = $("dietMode");
    const mode = dm?.value || "custom";
    const r = PROT_RANGES[mode];

    if (mode !== "custom" && r) {
      const v = clamp(toNum($("protPerKg").value), r.min, r.max);
      $("protPerKg").value = v.toFixed(1);
      setProtRangeUI(mode, false);
      saveProfileSettings();
      compute(true);
      return;
    }
    forceCustomIfPresetEdited();
    saveProfileSettings();
    compute(true);
  });

  // Calcul + scroll
  $("calcSpendBtn")?.addEventListener("click", () => compute(true, true));

  // Repas
  $("btnAddMeal")?.addEventListener("click", addMealFromInputs);
  $("btnClearMeals")?.addEventListener("click", clearMealsForDay);
  $("btnApplyPer100")?.addEventListener("click", applyPer100ToMeal);

["sportMin","sportKcal","sportType","sleepH","sleepScore","sleepBed","sleepWake"].forEach(id=>{
  $(id)?.addEventListener("change", () => {
    const d = getSelectedDate();
    saveSportSleepForDay(d);
    renderSportSleep7d(d);
  });
});


  // Historique : delete all
  $("btnDeleteDay")?.addEventListener("click", () => {
    const n = loadDays().length;
    if (!n) return;
    if (!confirm(`Supprimer TOUT l’historique (${n} journée(s)) ?`)) return;
    deleteAllDays();
    const d = isoToday();
    if ($("dayDate")) $("dayDate").value = d;
    renderMealsTable(d);
    updateBodyCompUI(d);
    compute(true);
  });

  $("btnExportDays")?.addEventListener("click", exportDays);
  $("btnImportDays")?.addEventListener("click", importDays);
  $("btnClearDays")?.addEventListener("click", clearDays);

  // Cloud
  $("btnCloudLogin")?.addEventListener("click", () => cloudLoginWithEmail($("cloudEmail")?.value));
  $("btnCloudLogout")?.addEventListener("click", cloudLogout);
  $("btnCloudPull")?.addEventListener("click", cloudPull);
  $("btnCloudPush")?.addEventListener("click", cloudPush);
  $("btnCloudSync")?.addEventListener("click", cloudSync);

  // Date change
  $("dayDate")?.addEventListener("change", () => {
    const d = getSelectedDate();
    if (getDay(d)) { loadDayIntoForm(d); diab_updateQuickKpis(d); return; }
    renderMealsTable(d);
    updateBodyCompUI(d);
    diab_updateQuickKpis(d);
    compute(true);

$("dayDate")?.addEventListener("change", () => {
  const d = getSelectedDate();

  if (getDay(d)) {
    loadDayIntoForm(d);
    loadSportSleepIntoUI(d);
    renderSportSleep7d(d);
    diab_updateQuickKpis(d);
    return;
  }

  renderMealsTable(d);
  updateBodyCompUI(d);
  loadSportSleepIntoUI(d);   // met des 0 propres
  renderSportSleep7d(d);
  diab_updateQuickKpis(d);
  compute(true);
});

  });

  // Autosave
  const autoSaveIds = ["sex","age","height","weight","montre","errPct","errMode","dietMode","carbGoal","carbCapGPerKg","ratioCP","lowCarbEnabled","lowCarbLevel","lowCarbStep"];
  autoSaveIds.forEach(id => $(id)?.addEventListener("change", () => { saveProfileSettings(); compute(true); }));

  ["morningWeight","fatPct","musclePct","boneKg"].forEach(id => {
    const el = $(id);
    if (!el) return;
    el.addEventListener("change", () => {
      const dateStr = getSelectedDate();
      saveBodyCompForDay(dateStr);
      updateBodyCompUI(dateStr);
      compute(true);
    });
  });

  // Carb-guard & low-carb toggles
// Carb-guard & low-carb toggles (exclusivité symétrique, sans verrou UI)
$("carbGuardEnabled")?.addEventListener("change", () => {
  // si j'active les repères => je coupe le low-carb
  if ($("carbGuardEnabled").checked && $("lowCarbEnabled")) $("lowCarbEnabled").checked = false;
  syncCarbModeUI();
  saveProfileSettings();
  compute(true);
});

$("lowCarbEnabled")?.addEventListener("change", () => {
  // si j'active le low-carb => je coupe les repères
  if ($("lowCarbEnabled").checked && $("carbGuardEnabled")) $("carbGuardEnabled").checked = false;
  syncCarbModeUI();
  saveProfileSettings();
  compute(true);
});

$("lowCarbLevel")?.addEventListener("change", () => { populateLowCarbSteps(); saveProfileSettings(); compute(true); });
$("lowCarbStep")?.addEventListener("change", () => {
    const lvl = $("lowCarbLevel")?.value || "moderate";
    setLowCarbRangeUI(lvl, true); // clamp + maj min/max + hint
    saveProfileSettings();
    compute(true);
  });

  $("lowCarbLevel")?.addEventListener("change", () => { populateLowCarbSteps(); saveProfileSettings(); compute(true); });
  $("lowCarbStep")?.addEventListener("change", () => {
    const lvl = $("lowCarbLevel")?.value || "moderate";
    setLowCarbRangeUI(lvl, true); // clamp + maj min/max + hint
    saveProfileSettings();
    compute(true);
  });
}

/* =====================================================================
   14) App Init (ordre d’exécution explicite)
   ===================================================================== */
function initApp(){
  initTabs();
  initPinnedTips();

  // (Diab) si dispo
try{ diab_initHistorySuivi?.(); }catch(e){}
  try{ diab_refreshHistoryUI?.(); }catch(e){}

  ensureDefaultProfile();
  refreshProfileSelect();

  if ($("dayDate")) $("dayDate").value = isoToday();

  applyBrandPreset($("watchBrand").value, true);

  if ($("carbGoal")) initCarbGuardsUI();

  loadProfileSettings();

  // CGU init
  const accepted = isTermsAccepted();
  if ($("ackTerms")) $("ackTerms").checked = accepted;
  setAppLocked(!accepted);

  lockMacroControls($("dietMode").value === "custom");
  updateCarbGuardExplain();
  updateFatFloorUI();

  syncCarbModeUI();

  if ($("dietMode")?.value && $("dietMode").value !== "custom") setDietNote($("dietMode").value, false);

  refreshDaySelect();
  renderDaysHistory();
  renderMealsTable(getSelectedDate());

loadSportSleepIntoUI(getSelectedDate());
renderSportSleep7d(getSelectedDate());

  updateBodyCompUI(getSelectedDate());
  applyUseMode($("useMode")?.value || "simple");

  // Cloud boot (si supa dispo)
  (async () => {
    if (!supa) { setCloudStatus("local uniquement (Supabase non configuré)."); return; }
    await handleMagicLinkCallback();
    const user = await cloudGetUser();
    setCloudStatus(user ? ("connecté : " + (user.email || "utilisateur")) : "non connecté.");
  })();

  compute(true);
}


/* =====================================================================
   PATCH v17.2 — corrections ciblées (sans refonte)
   - Fix mapping carbGoal (UI values) -> internal keys (FAT_FLOORS + steps)
   - Fix repères glucidiques (updateCarbSteps) + plancher lipides
   - Fix rappel rapide (setPositioningCopy) : doublon écrasant
   ===================================================================== */

(function(){
  // 1) Aliases pour objectifs glucidiques (valeurs HTML -> clés internes)
  const CARB_GOAL_ALIAS = {
    none: "none",
    dry_strict: "strict",
    dry_sport: "sport",
    recomp: "recomp",
    maintain_active: "maintain",
    endurance_volume: "volume",
    carb_loading: "carbload"
  };

  function normCarbGoalKey(v){
    const k = (v || "none");
    return CARB_GOAL_ALIAS[k] || k;
  }

  // 2) Étend FAT_FLOORS avec les valeurs UI (sans casser l'existant)
  try{
    if (typeof FAT_FLOORS === "object" && FAT_FLOORS){
      FAT_FLOORS.dry_strict       = FAT_FLOORS.strict;
      FAT_FLOORS.dry_sport        = FAT_FLOORS.sport;
      FAT_FLOORS.maintain_active  = FAT_FLOORS.maintain;
      FAT_FLOORS.endurance_volume = FAT_FLOORS.volume;
      FAT_FLOORS.carb_loading     = FAT_FLOORS.carbload;
      FAT_FLOORS.none             = { min: 0, note: "-" };
    }
  }catch(e){ /* noop */ }

  // 3) Patche fatFloorForGoal pour accepter les valeurs UI
  try{
    const _fatFloorForGoal = fatFloorForGoal;
    window.fatFloorForGoal = function(goalKey){
      return _fatFloorForGoal(normCarbGoalKey(goalKey));
    };
  }catch(e){ /* noop */ }

  // 4) updateFatFloorUI : utilise clés normalisées + évite incohérences
  try{
    const _updateFatFloorUI = updateFatFloorUI;
    window.updateFatFloorUI = function(){
      const raw = ($("carbGoal")?.value) || "none";
      // force la normalisation via fatFloorForGoal patché
      return _updateFatFloorUI();
    };
  }catch(e){ /* noop */ }

  // 5) Repères glucidiques : remplace updateCarbSteps (mapping correct)
  window.updateCarbSteps = function updateCarbSteps(){
    const rawGoal = $("carbGoal")?.value || "none";
    const goal = normCarbGoalKey(rawGoal);
    const mode = $("dietMode")?.value || "none";

    // si pas de régime, ou pas d'objectif choisi
    if (mode === "none" || rawGoal === "none"){
      resetCarbGoalDerivedUI();
      updateFatFloorUI();
      updateCarbGuardExplain();
      return;
    }

    const stepSel = $("carbStep");
    const capInp  = $("carbCapGPerKg");
    const ratioInp= $("ratioCP");
    if (!stepSel || !capInp || !ratioInp) return;

    const w = Math.max(0, toNum($("weight")?.value));

    const RANGES = {
      strict:   { min: 2.0,  max: 3.0,  recRatio: 1.00 },
      sport:    { min: 3.0,  max: 4.0,  recRatio: 1.10 },
      recomp:   { min: 4.0,  max: 5.0,  recRatio: 1.25 },
      maintain: { min: 4.0,  max: 6.0,  recRatio: 1.50 },
      volume:   { min: 6.0,  max: 8.0,  recRatio: 1.80 },
      carbload: { min: 8.0,  max: 12.0, recRatio: 2.50 }
    };
    const r = RANGES[goal] || RANGES.sport;

    // rebuild steps
    stepSel.innerHTML = "";
    const steps = [];
    for (let v = r.min; v <= r.max + 1e-9; v = Math.round((v + 0.1) * 10) / 10) steps.push(v);
    steps.forEach(v => {
      const opt = document.createElement("option");
      opt.value = String(v.toFixed(1));
      opt.textContent = v.toFixed(1) + " g/kg/j";
      stepSel.appendChild(opt);
    });

    capInp.step = "0.1";
    capInp.min  = String(r.min);
    capInp.max  = String(r.max);

    const cur = toNum(capInp.value);
    const next = (cur > 0 && cur >= r.min - 1e-9 && cur <= r.max + 1e-9) ? cur : r.min;
    capInp.value = next.toFixed(1);
    stepSel.value = capInp.value;

    // ratio conseillé (si vide/0)
    const ratioCur = toNum(ratioInp.value);
    if (ratioCur <= 0) ratioInp.value = r.recRatio.toFixed(2);

    // UI hints
    const capG = toNum(capInp.value);
    const maxCarbsG = (w > 0) ? Math.round(capG * w) : 0;
    const explain = $("carbGuardExplain");
    if (explain){
      explain.textContent =
        `Plafond glucides : ${capG.toFixed(1)} g/kg/j (≈ ${maxCarbsG} g/j pour ${Math.round(w)} kg). ` +
        `Ratio max C/P conseillé ≈ ${toNum(ratioInp.value).toFixed(2)}.`;
    }
    const autoHint = $("carbAutoHint");
    if (autoHint){
      autoHint.value = `Plafond glucidique : ${capG.toFixed(1)} g/kg/j (≈ ${maxCarbsG} g/j)`;
    }

    try{ applyRatioPriority('updateCarbSteps'); }catch(e){}

    updateFatFloorUI();
    updateCarbGuardExplain();
  };

  
  // 5bis) PATCH RatioCP — priorité nette (mode régime vs repères vs low-carb)
  // Règle :
  // - Repères OFF : ratioCP libre (on mémorise la valeur utilisateur)
  // - Repères ON  : ratioCP = ratio d’objectif (verrouillé) et écrase la valeur libre
  // - Repères OFF à nouveau : on restaure la valeur libre
  // - Low-carb ON : ratio affiché "--" (ratio inactif), sans écraser la valeur libre mémorisée
  function _ratioFreeKey(){
    try { return String(SETTINGS_KEY()) + ".ratioCP_free"; } catch(e){ return "ratioCP_free"; }
  }
  function getFreeRatio(){
    try {
      const v = localStorage.getItem(_ratioFreeKey());
      const n = toNum(v);
      return (Number.isFinite(n) && n > 0) ? n : 0;
    } catch(e){ return 0; }
  }
  function setFreeRatio(v){
    try {
      const n = toNum(v);
      if (Number.isFinite(n) && n > 0) localStorage.setItem(_ratioFreeKey(), String(round(n,2)));
    } catch(e){}
  }

  function objectiveRatioForGoal(rawGoal){
    const goal = normCarbGoalKey(rawGoal);
    const R = {
      strict:   { recRatio: 1.00 },
      sport:    { recRatio: 1.10 },
      recomp:   { recRatio: 1.25 },
      maintain: { recRatio: 1.50 },
      volume:   { recRatio: 1.80 },
      carbload: { recRatio: 2.50 }
    };
    return toNum((R[goal] || R.sport).recRatio);
  }

  function applyRatioPriority(reason){
    const ratioNum = $("ratioCP");
    const ratioTxt = $("ratioCPText");
    const carbGuard = !!$("carbGuardEnabled")?.checked;
    const lowCarb   = !!$("lowCarbEnabled")?.checked;
    const rawGoal   = $("carbGoal")?.value || "none";
    const mode      = $("dietMode")?.value || "none";

    if (!ratioNum) return;

    // mémorise la valeur libre si l'input est actuellement libre
    const canStoreFree = !ratioNum.disabled && !lowCarb;
    if (canStoreFree){
      const cur = toNum(ratioNum.value);
      if (Number.isFinite(cur) && cur > 0) setFreeRatio(cur);
    }

    // Low-carb : ratio inactif + affichage "--"
    if (lowCarb){
      // ne pas écraser la valeur libre mémorisée
      ratioNum.classList.add("hidden");
      ratioNum.disabled = true;

      if (ratioTxt){
        ratioTxt.classList.remove("hidden");
        ratioTxt.value = "--";
      }
      return;
    } else {
      // remettre l'input numérique
      if (ratioTxt) ratioTxt.classList.add("hidden");
      ratioNum.classList.remove("hidden");
    }

    // Pas de régime ou pas d'objectif : repères ne doivent pas forcer un ratio
    const noObjective = (mode === "none" || rawGoal === "none");

    if (carbGuard && !noObjective){
      // verrouille sur le ratio d'objectif
      const obj = objectiveRatioForGoal(rawGoal);
      ratioNum.value = (Number.isFinite(obj) && obj > 0) ? obj.toFixed(2) : "0";
      ratioNum.disabled = true;
    } else {
      // ratio libre : restaurer si possible
      ratioNum.disabled = false;
      const stored = getFreeRatio();
      if (stored > 0){
        ratioNum.value = stored.toFixed(2);
      } else {
        // si rien en mémoire, laisser tel quel (sans imposer)
        if (!(toNum(ratioNum.value) > 0)) ratioNum.value = "0";
      }
    }
  }


// 6) Fix rappel rapide : écrase le doublon (modeCopy -> positioningText)
  window.setPositioningCopy = function setPositioningCopy(mode){
    const el = $("positioningText");
    if (!el) return;
    const m = (mode === "sport" || mode === "expert") ? mode : "simple";

    if (m === "sport") {
      el.textContent = "Mode sportif : tu peux ajuster plus finement (marge d’erreur, charge, ratio...). Lis surtout la tendance 7 jours.";
    } else if (m === "expert") {
      el.textContent = "Mode expert : la valeur du jour peut varier. Lis surtout la tendance sur 7 jours.";
    } else {
      el.textContent = "Mode simple : vise la régularité sur 7 jours. Affichage allégé, sans pression au quotidien.";
    }
  };

  // 7) CSS patch via structure patch
  try{
    if (typeof patch === "object" && patch){
      patch.css += `
/* PATCH v17.2 */
#carbGuardExplain{ margin-top:.35rem; }
#ratioCPText{ width:100%; }
`;
      patch.apply();
    }
  }catch(e){ /* noop */ }

  // Wire priorité RatioCP (sans casser wireEvents)
  try{
    $("carbGuardEnabled")?.addEventListener("change", () => applyRatioPriority("carbGuardEnabled"));
    $("lowCarbEnabled")?.addEventListener("change", () => applyRatioPriority("lowCarbEnabled"));
    $("carbGoal")?.addEventListener("change", () => applyRatioPriority("carbGoal"));
    $("dietMode")?.addEventListener("change", () => applyRatioPriority("dietMode"));
    $("ratioCP")?.addEventListener("input", () => {
      if (!$("carbGuardEnabled")?.checked && !$("lowCarbEnabled")?.checked){
        setFreeRatio(toNum($("ratioCP").value));
      }
    });
  }catch(e){}

})();

wireEvents();
initApp();
</script>
<section class="card">
<h2>Sources</h2>
<p class="muted" style="margin-top:.4rem">
      Références (à vérifier) :
      <br/>• Thomas DT, Erdman KA, Burke LM. <i>Nutrition and Athletic Performance</i>. Med Sci Sports Exerc. 2016. (PubMed / DOI) 
      <br/>• Rodriguez NR et al. <i>ACSM position stand: Nutrition and athletic performance</i>. Med Sci Sports Exerc. 2009. (PubMed / DOI)
      <br/>• Kerksick CM et al. <i>ISSN Position Stand: nutrient timing</i>. J Int Soc Sports Nutr. 2017. (PDF ISSN)
      <br/>• “From Plate to Performance…” Applied Sciences. 2025. (article avec tableau g/kg/j)
    </p>
</section>
</div></body>
</html>
